<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[JavaScript之正则表达式入门(基本语法与应用案例)]]></title>
      <url>%2F2017%2F08%2F15%2FJavaScript%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7%E4%B8%8E%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B%2F</url>
      <content type="text"><![CDATA[简述正则表达式的实现最早来自 Unix 系统, 并不是 JS 一家独有, 而是一套通用语法, 各家实现略有不同. 虽说目前 JS 技术发展迅速, 但很多部分都是借鉴其他语言的特性和框架发展而来的. 很多人对正则头痛, 常常写匹配时忘记语法如何写了. 😂 复杂度较高的的组合使用, 阅读性也很低, 例如 /^[-a-z0-9~!$%^&amp;*_=+}{\&#39;?]+(\.[-a-z0-9~!$%^&amp;*_=+}{\&#39;?]+)*@([a-z0-9_][-a-z0-9_]*(\.[-a-z0-9_]+)*\.(aero|arpa|biz|com|coop|edu|gov|info|int|mil|museum|name|net|org|pro|travel|mobi|[a-z][a-z])|([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}))(:[0-9]{1,5})?$/i , 这是一段邮箱认证的正则. 正则出现的频率并不高, 出现时却有尚方宝剑的效果, 能一招见效, 达成目的, 正则是我们拿来精准匹配和替换的利器. 本篇旨在探索基本语法在实际中的应用. 基本语法 字符 含义 . 任意一个字符,不包括 \n\r ^ 以什么开始 $ 以什么结束 * 元字符出现0或多次 + 元字符出现1或多次 ? 元字符出现0或1次 {n} 出现n次 {n,} 出现最少n次 {n,m} 出现n到m次之间 [ ] 匹配\n以外的单字字符 [ab] 匹配a或b [a-d] 匹配一个a到d之间的小写字母 %[^a-zA-Z]% 两个百分号之间不应该出现字母, ^ \b 单词边界 \d 匹配一个数字 \D 匹配一个非数字 \s 匹配一个空白字符 \S 匹配一个非空白字符 \w 匹配一个非特殊字符, 包括_ \W 匹配一个特殊字符 \ 转义字符, 正则语法中^.$()¦*+?{}\如需要匹配字符串中对应字符需要使用转义字符\ g 全局替换 i 忽略大小写 相关属性和方法正则实例的属性 实例拥有5个属性: global：是否全局搜索，默认是false ignoreCase：是否大小写敏感，默认是false multiline：多行搜索，默认值是false lastIndex：是当前表达式模式首次匹配内容中最后一个字符的下一个位置，每次正则表达式成功匹配时，lastIndex属性值都会随之改变。 source：正则表达式的文本字符串 正则原型的方法我们可以用下面的方法创造一个正则表达式, 1234// new 一个let pattern1 = new RegExp('abc');// 字面量生成let pattern2 = /^\S/; 这两种创造正则表达式的效果是相同的. 可以用 new 来生成实例, 可见 RegExp 是一个构造函数, 那我们就去他的原型上看看都有哪些方法可用. 12Object.prototype.toString.call(RegExp)// [object Function] 我们可以看到, 有下面3个可用的方法: test exec compile test()test 用于匹配字符串中是否存在符合正则匹配规则的字符, 存在返回 true, 不存在返回 false. 1234let part = /o/g;let ret = part.test('Hello World');console.log(ret);// true exec()exec 用于匹配字符串中是否存在符合正则匹配规则的字符, 存在返回一个数组, 包含匹配到的字符, 不存在返回 null . 1234let part = /o/g;let ret = part.exec('Hello World');console.log(ret);// ["o", index: 4, input: "Hello World"] 如果全局匹配, 多次运行, 会返回后面新匹配到的索引. 1234567891011let part = /e/g;do &#123;result=part.exec("The best things in life are free");console.log(result);&#125; while (result!=null)// ["e", index: 2, input: "The best things in life are free"]// ["e", index: 5, input: "The best things in life are free"]// ["e", index: 22, input: "The best things in life are free"]// ["e", index: 26, input: "The best things in life are free"]// ["e", index: 30, input: "The best things in life are free"]// ["e", index: 31, input: "The best things in life are free"] compile()compile 用于替换正则表达式的匹配规则, 编译正则为接近计算机底层编码格式. 1234567891011let part = /e/;// 方法 1part.compile('abc','g');console.log(part);// /abc/g// 方法 2part.compile(/def/);console.log(part);// /def/ 到这里有人可能有疑问了, 这和我重新赋值一个新的正则表达式有什么区别? 区别还是有的, 我们使用的编程语言是经由机器码多次编译而来的, compile 可以编译为便于计算机理解的代码, 提升运行速度. 简单的匹配时没有明显速度差异的, 如果是大数据, 数据体量极大, 正则的执行速度差异就体现出来了. 字符串和正则相关的方法字符串原型上有4个方法和正则相关联. String.prototype.search String.prototype.match String.prototype.replace String.prototype.split String.prototype.searchsearch 用于检索字符串的制定子字符串, 返回索引位置(Number类型), 检索不成功返回 -1, 参数可用字符串与正则表达式匹配. 不能全局检索, 只能匹配一次, 忽略 g, 匹配成功立即返回. 12345let str = 'Hello World';console.log(str.search('H')); // 0console.log(str.search('h')); // -1console.log(str.search(/World/)); // 6 String.prototype.match1let str = 'Hello World'; 单次匹配, 返回一个数组, 包含 index 属性 和 input 属性, index 为匹配到的索引位置, input 为被匹配的父字符串, 返回值与 exec 相同. 全局匹配, 返回一个数组, 不包含 index 属性 和 input 属性, 匹配到的子字符串会以数组形式放置, 返回值与 exec 不同. String.prototype.replacereplace 方法并不改变字符串本身, 而是返回替换后的新字符串. 1234let str = 'Hello World';str.replace('o','aaa') // "Hellaaa World"str.replace(/o/gi, 0) // "Hell0 W0rld" replace 的第二个参数也可以是函数, 参数有如下这些 | 参数 | 代表的数值 || match | 匹配的子字符串 || p1,p2, … | 匹配的每个字符串 || offset | 匹配到的子字符串在原字符串中的偏移量。（比如，如果原字符串是“abcd”，匹配到的子字符串是“bc”，那么这个参数将是1） || string | 被匹配的原字符串 | 12345function replacer(match, p1, p2, p3, offset, string) &#123; // p1 is nondigits, p2 digits, and p3 non-alphanumerics return [p1, p2, p3].join(' - ');&#125;var newString = 'abc12345#$*%'.replace(/([^\d]*)(\d*)([^\w]*)/, replacer); // 'abc - 12345 - #$*%'： 已字符串作为参数, 可以使用以下特殊语句: 特殊字符 含义 $$ 插入一个 “$”。 $&amp; 插入匹配的子串。 `$`` 插入当前匹配的子串左边的内容。 $&#39; 插入当前匹配的子串右边的内容。 $n 假如第一个参数是 RegExp对象，并且 n 是个小于100的非负整数，那么插入第 n 个括号匹配的字符串。 123456// 交换字符串中的两个单词var re = /(\w+)\s(\w+)/;var str = "John Smith";var newstr = str.replace(re, "$2, $1");console.log(newstr);// Smith, John String.prototype.splitsplit 的参数可以用字符串和正则表达式匹配 12let str = 'HellosWorld';str.split(/s/); // ["Hello", "World"] 应用案例表单验证待补充 参考资料 W3C MDN]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5之WebSocket拆解]]></title>
      <url>%2F2017%2F08%2F09%2FHMTL5%E4%B9%8Bwebsocket%E6%8B%86%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[客户端要即时获取服务端的消息, 以前的做法是使用 Ajax长轮询 或 commet 持久连接来实现, 但这样很耗费服务端带宽资源, 使用长轮询需要服务器有优秀的响应速度, 持久连接则需要服务端有良好的高并发能力. 基于这种现状, 才有了 WebSocket 通讯协议的诞生. 为什么需要 WebSocket ?目前的网络数据的传输是遵循 HTTP 1.1 传输的, 目前 HTTP协议 的缺点就是请求只能从客户端发起, 服务端无法对客户端推送消息, 所以才有长轮询和 commet 这些解决方案. 为了解决这种现状, 才有了 WebSocket 的诞生. WebSocket 有什么特点?(1) 建立在 TCP/IP 协议之上, 兼容性好, 客户端和服务端比较容易实现 (2) 没有浏览器同源限制, 服务端不用设置 CORS (3) 客户端和服务端互相可以实时推送 (4) 协议标识符使用 ws , 如果加密则使用 wss (5) 一次连接, 持久有效, 有状态连接 WebSocket 和 HTTP 的区别WebSocket 和 HTTP 的区别可以借用下面两张图表示( 侵删 ): WebSocket API因服务端语言各有实现方式, 这里阐述下客户端的 API: 123456789101112131415161718192021// 创建 Socket 实例let ws = new WebSocket("wss://echo.websocket.org");// 连接成功ws.onopen = function(evt) &#123; console.log("Connection open ..."); // 初始化消息 ws.send("Hello WebSockets!");&#125;;// 发送消息ws.onmessage = function(evt) &#123; console.log( "Received Message: " + evt.data); // 关闭 Socket ws.close();&#125;;// 关闭连接或停止正在进行的链接请求ws.onclose = function(evt) &#123; console.log("Connection closed.");&#125;; 详细属性可点击这里查看. WebSocket 应用虽然现代浏览器都已经支持 WebSocket , 也有 IE 这样不出乎意料的例外, 所幸目前有一款集成和兼容性都比较好的封装, socket.io . Socket.IO 使用检测功能来判断是否建立 WebSocket 连接，或者是 AJAX long-polling 连接，或 Flash 等。可快速创建实时的应用程序. 基于 Nodejs 实现一个简单的聊天室应用12345678910111213141516171819// nodejs 服务端代码let app = require('express')();let http = require('http').Server(app);let io = require('socket.io')(http);app.get('/', function(req, res)&#123; res.sendFile(__dirname + '/index.html');&#125;);io.on('connection', function(socket)&#123; socket .on('chat message', function(msg)&#123; io.emit('chat message', msg); &#125;);&#125;);http.listen(3000, function()&#123; console.log('listening start, port: 3000');&#125;); 123456789101112131415161718192021&lt;!-- HTML 客户端代码 --&gt;&lt;ul id="messages"&gt;&lt;/ul&gt;&lt;form action=""&gt; &lt;input id="m" autocomplete="off" /&gt; &lt;button type="submit"&gt;Send&lt;/button&gt;&lt;/form&gt;&lt;script src="https://code.jquery.com/jquery-1.11.1.js"&gt;&lt;/script&gt;&lt;script src="/socket.io/socket.io.js"&gt;&lt;/script&gt;&lt;script&gt; $(function () &#123; var socket = io(); $('form').submit(function()&#123; socket.emit('chat message', $('#m').val()); $('#m').val(''); return false; &#125;); socket.on('chat message', function(msg)&#123; $('#messages').append($('&lt;li&gt;').text(msg)); &#125;); &#125;);&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM3中9个鼠标事件]]></title>
      <url>%2F2017%2F07%2F27%2FJavaScript%2FDOM3%E4%B8%AD9%E4%B8%AA%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[今天看到一篇描述 click 事件的发生的条件, 需要同时满足 mousedown 和 mouseup 事件,也就是鼠标按下和抬起行为在同一个元素触发才会触发 click. 另外找出 DOM3 中的9个鼠标事件回顾一下: click 在用户单击主鼠标按钮（一般是左边的按钮）或者按下回车键时触发。这一点对确保易访问性很重要，意味着onclick事件处理程序既可以通过键盘也可以通过鼠标执行. dblclick 在用户双击主鼠标按钮（一般是左边的按钮）时触发。从技术上说，这个事件并不是DOM2级事件规范中规定的，但鉴于它得到了广泛支持，所以DOM3 级事件将其纳入了标准 mousedown 在用户按下了任意鼠标按钮时触发。不能通过键盘触发这个事件. mouseup 在用户释放鼠标按钮时触发。不能通过键盘触发这个事件. mouseenter 在鼠标光标从元素外部首次移动到元素范围之内时触发。这个事件不冒泡，而且在光标移动到后代元素上不会触发。DOM2级事件并没有定义这个事件，但 DOM3级事件将它纳入了规范。IE、Firefox 9+和 Opera支持这个事件. mouseleave 在位于元素上方的鼠标光标移动到元素范围之外时触发。这个事件不冒泡，而且在光标移动到后代元素上不会触发。DOM2级事件并没有定义这个事件，但DOM3级事件将它 纳入了规范。IE、Firefox 9+和 Opera支持这个事件. mousemove 当鼠标在元素内部移动时触发事件, 可以获得 client&amp;screen 坐标. mouseover 鼠标移入元素时触发事件, 会冒泡到子父代元素. mouseout 鼠标移出元素时触发事件, 会冒泡到子父代元素.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript之Object拆解]]></title>
      <url>%2F2017%2F07%2F26%2FJavaScript%2FJavaScript%E4%B9%8BObject%E6%8B%86%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[让我们一起来拆解一下 Object 相关联的属性、方法和 ES6 后新 Api 吧: 属性类型JavaScript 中有两种数据类型: 数据属性和访问器属性 数据属性数据属性有以下几个描述行为的属性: Configurable 描述这个属性是否可被 delete 删除, 默认为 true Enumerable 描述这个属性是否可被枚举, 默认为 true writable 描述这个属性是否可被修改, 默认为 true value 描述这个属性的值 如果想要修改这些系统默认属性, 可以通过 ES5 的方法 Object.defineProperty(obj, property, option). 注意: 可以多次调用 Object.defineProperty() 修改属性, 但将 Configurable 设置为 false 是不可逆的. 调用 Object.defineProperty() 修改属性方法时, 如果不指定这些描述属性, 则默认值都会设置为 false. 访问器属性访问器有以下几个属性: Configurable 描述这个属性是否可被 delete 删除, 默认为 true Enumerable 描述这个属性是否可被枚举, 默认为 true get 在读取属性时调用的函数, 默认为 undefined set 在设置属性时调用的函数, 默认为 undefined 1234567891011121314151617181920let book = &#123; _year: 2004, edition: 1 &#125;;/* * 第一个参数: 对象 * 第二个参数: 对象的属性 * 第三个参数: 需要设置的描述属性 */Object.defineProperty(book, 'year', &#123; get: function() &#123; return this._year; &#125;, set: function(newValue) &#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125;&#125;);book.year = 2009;console.log(book.edition); // 6 注意: get 和 set 必须同时设置, 否则会出现不能读或不能写的情况 如果要一次修改多个参数的描述属性, 可以使用 Object.defineProperties() 12345678910let book = &#123;&#125;;Object.defineProperties(book, &#123; _year: &#123; value: 2004 &#125;, edition: &#123; value: 1 &#125;&#125;); 构造函数构造函数也是普通的函数, 如果没有通过 new 操作符生成新的实例对象, 那构造函数就是一个普通的函数.为了区分构造函数于普通函数, 我们通常用大驼峰命名法给构造函数命名.String、Array 等几乎所有对象都是 Object 的实例, Object 就是一个构造函数. 123new Array() instanceof Object // truenew String() instanceof Object // truenew Function() instanceof Object // true 1234567891011function Info() &#123; this.name = 'XingChuan'; this.age = '10';&#125;let info1 = new Info();let info2 = new Info();console.log(info1.name); // XingChuanconsole.log(info1.age); // 10console.log(info2.name); // XingChuanconsole.log(info2.age); // 10 原型对象既然谈到构造函数就要谈到原型了, 每个函数都有一个原型(prototype)属性, 原型存在的意义就是, 原型上的属性和方法由所有构造函数的实例对象所共享, 如果修改了原型对象上的方法, 那所有实例都会实时更改. 我们平时使用 Array 和 String 的方法, 都是在其原型对象上, 所有我们创建的所有数组和字符串都可以享有这些方法. 原型链在 chrome, firefox, safari 中, 有一个浏览器私有属性 __proto__ 指向构造函数的 prototype, __proto__ 并不是官方属性, 为了兼容性考虑, 开发中最好不要使用 __proto__. 下面我们来具象化一下原型链的构成: 函数的原型链构造函数也是普通的函数, 只是我们拿来生成实例, 所以才有这个称谓, 而所有的函数都是 Function 的实例. 123function info() &#123;&#125; 12// 原型链info.__proto__ =&gt; Function.prototype =&gt; Object.prototype 所有的函数都是 Function 的实例, 而 Function 是 Object 的实例, 所以有了这条原型链. 内置对象的原型链很有意思的是, Object、Array、String、Function 都是函数, 所以他们都是 Function 的实例, Function 比较特殊, 它也是自身的实例. Math 是个例外, 它并不是一个函数, 而是一个对象. 123456console.log(Array instanceof Function) // trueconsole.log(String instanceof Function) // trueconsole.log(Object instanceof Function) // trueconsole.log(Function instanceof Function) // trueconsole.log(Math instanceof Function) // falseconsole.log(Math.__proto__ === Object.prototype); // true 12// 原型链Array.__proto__ =&gt; Function.prototype =&gt; Object.protytype 实例对象的原型链123456789101112function Info() &#123;&#125;Info.prototype.name = 'Xingchuan';Info.prototype.age = 10;Info.prototype.showName = function() &#123; console.log(this.name);&#125;;let info1 = new Info();info1.showName() // XingChuanlet info2 = new Info();info2.name = 'test';info2.showName() // test 12// 原型链info1.__proto__ =&gt; Info.prototype =&gt; Object.prototype 实例对象的 __proto__ 会指向构造函数的 prototype, 所有的原型对象都是 Object.prototype 的实例, 所以构成了这一条原型链. 注意: 原型链的访问是有就近原则的, 如果像上面实例中已经有 name 属性, 则不会继续访问 prototype 上的 name 属性, 如果实例中没有这个属性, 则会按照原型链一直找下去, 如果没有就是 undefined. 元素也是 Object 的实例1234console.dir(document.getElementsByTagName('span')[0]);// span元素 =&gt; HTMLSpanElement =&gt; HTMLElement =&gt; Element =&gt; Node =&gt; EventTarget =&gt; Object.prototypeconsole.dir(document.getElementsByTagName('span')[0] instanceof Object);// true 元素的原型链很长, 不过可以看到元素也是 Object 的实例. 小结 原型链有就近原则, 如果在实例上访问到某属性, 就不会继续原型链寻找该属性了 原型是可以重新指定的 prototype 的 constructor 指向 构造函数 实例的 __proto__ 指向构造函数的 prototype 所有函数的 __proto__ 指向 Function.prototype 函数的 prototype 都是基于 Object.prototype Function 也是自己的实例 一切起源于 Object.prototype 每个原型都有 constructor 属性, 指向原型所属的函数, 用字面量对象改为原型的引用, 会丢失 constructor 这个属性 来张示意图结尾( 侵删 ): this 的指向 一书中对 this 指向的问题有比较详细的描写, 推荐看看. 在讨论 this 指向的问题之前, 先要明确一下, 在严格模式下, 未指定环境对象而调用函数，则 this 值不会转型为 window.除非明确把函数添加到某个对象或者调用 apply()或 call()，否则 this 值将是 undefined. 普通函数中的 this 12345let x = 1;function show() &#123; console.log(this.x);&#125;show(); // 1 普通函数中的 this 指向 window 构造函数中的 this 12345function Info()&#123; this.x = 1;&#125;let info1 = new Info();console.log(info1.x); // 1 构造函数中的 this 指向 new 出来的实例对象, new 这个操作符会改变 this 的指向. 对象方法中的 this 12345678910let x = 2;let obj = &#123; x: 1, y: function() &#123; console.log(this.x); &#125;&#125;;obj.y(); // 1对象方法中的 this 指向调用它的对象. call、apply、bind(ES5) 中的 this call、apply、bind(ES5) 的作用就是改变 this 的指向, this 会指向第一个参数. 如果 call、apply、bind(ES5) 调用方法时没有传参, 默认 this 指向 window. bind 只会改变 this 的指向, 并不会执行方法, call 和 apply 则会改变指向时也执行方法. 事件函数中的 this 事件函数中的 this 指向绑定事件的元素. 箭头函数中的 this 箭头函数是 ES6 中新增的方法, 不同于其他情况中的 this 在调用时才决定指向, 箭头函数 this 指向定义时的外围, 在不确认指向的情况下, 请慎用. 12345ECMAScript 6 入门对箭头函数的使用限制做了说明:（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。（4）不可以使用yield命令，因此箭头函数不能用作Generator函数。 数据类型判断在开发中, 我们可以用 typeof 来判断类型, 但有很大的局限性. 12345678910111213141516typeof 1// "number"typeof '1'// "string"typeof true// "boolean"typeof undefined// "undefined"typeof null// "object"typeof (function()&#123;&#125;)// "function"typeof []// "object"typeof &#123;&#125;// "object" typeof 只对一些简单数据类型有效, 为了可以判断各种内置对象, 我们需要采取一些 手段 , 使用 Object 原型上的 toString 方法. 1234567891011121314151617181920Object.prototype.toString.call(1);// "[object Number]"Object.prototype.toString.call('1');// "[object String]"Object.prototype.toString.call(true);// "[object Boolean]"Object.prototype.toString.call(function() &#123;&#125;);// "[object Function]"Object.prototype.toString.call(null);// "[object Null]"Object.prototype.toString.call(undefined);// "[object Undefined]"Object.prototype.toString.call(new Date());// "[object Date]"Object.prototype.toString.call(Math);// "[object Math]"Object.prototype.toString.call([]);// "[object Array]"Object.prototype.toString.call(&#123;&#125;);// "[object Object]" 可以全部搞定了. ES6 之后的新特性对象属性的简洁写法 简洁的写法可以减少代码量也可以更加优雅, 但代码是给计算机看的, 同时也是给人看的, 容易发生歧义的地方一定要注意. 属性的简写 如果属性名与属性值相同, 可以忽略不写.属性值是字符串时不可简写. 123456789101112131415// oldlet name = 'XingChuan';let obj = &#123; name: name&#125;;// newlet name = 'XingChuan';let obj = &#123; name&#125;;// errorlet name = 'XingChuan';let obj = &#123; name:'name'&#125;; 函数的简写 123456789101112// oldlet obj = &#123; show: function() &#123; console.log('show'); &#125;&#125;;// newlet obj = &#123; show() &#123; console.log('show'); &#125;&#125;; 字面量形式定义对象ES5只支持这种字面量定义: 1234let obj = &#123; name: 'XingChuan', age: 10&#125;; ES6支持这种写法: 12345let obj =&#123; [name]: 'XingChuan', ['a' + 'ge']: 10&#125;;// 作为属性名的表达式会自动 toString() , 应避免使用对象作为表达式, 因为 String(&#123;&#125;) === '[object Object]' 注意: 属性名表达式与简洁表示法不能同时使用, 会报错 属性名表达式为对象时属性名会重复的问题 Object.is(‘’,’’) 同值相等APIObject.is() 基本等同于 === , 除却两点: 12345+0 === -0 // trueNaN === NaN // falseObject.is(+0, -0) // falseObject.is(NaN, NaN) // true Object.assign(target, source1, source2) 复制可枚举属性12345678910111213141516171819202122232425let target = &#123; info: &#123; name: 'name1' &#125;&#125;;let source1 =&#123; info: &#123; name: 'name2', age: 30 &#125;&#125;;let source2 =&#123; info: &#123; name: 'name3' &#125;&#125;;Object.assign(target, source1, source2);// &#123; info: &#123;name: 'name3'&#125;&#125;//// Object.assign 是浅拷贝, 如果属性的值是对象, 就会添加新的引用, 而不是在原有地址上添加属性.// target会自动转换为对象, 所以不能为 null 或 undefined , 会报错// source为 null 或 undefined 时, 因为无法转换为对象, 会跳过, 但不会报错// 若 source 为字符串, 会以数组的形式复制到 target 中// 属性的可枚举性每个对象属性都有一个描述对象 Description , 可以控制是否可被枚举, 数据属性的其中之一. 1234567891011let obj = &#123; name: 'XingChuan'&#125;;Object.getOwnPropertyDescriptor(obj,'name');// &#123;// configurable: true,// enumerable: true, // 如果可枚举为 false , 某些操作会忽略掉这个属性// value: "XingChuan",// writable: true// &#125; ES5 中有 3 个属性会忽略 enumerable 为 false 的属性: for…in 循环 Object.keys() JSON.stringify() ES6 新增的 Object.assign() 也会忽略描述中不可枚举的属性. 数组中的 length 属性不会被 for…in 获取就是因为不可枚举的描述. 12345678Object.getOwnPropertyDescriptor([1,2,3],'length');// &#123;// configurable: false,// enumerable: false,// value: 3,// writable: true// &#125; 另外, ES6 中也规定了 Class 原型上的方法是不可枚举的. 属性的遍历 for…in for…in 循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性） Object.keys(obj) Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性) Object.getOwnPropertyNames(obj) Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性） Object.getOwnPropertySymbols(obj) Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性 Reflect.ownKeys(obj) Reflect.ownKeys返回一个数组，包含对象自身的所有属性，不管属性名是 Symbol 或字符串，也不管是否可枚举 以上 5 种方法在遍历顺序上, 遵循以下 3 条规则: 首先遍历所有属性名为数值的属性，按照数字排序 其次遍历所有属性名为字符串的属性，按照生成时间排序 最后遍历所有属性名为 Symbol 值的属性，按照生成时间排序 __proto__, Object.getPrototypeOf(), Object.setPrototypeOf()__proto____proto__ 指向当前实例的原型对象, 其没有被 ES6 列为正式 API, 但因为被浏览器厂商广泛使用, 被收入附录. 某些浏览器厂商同样指向原型对象, 可能是另一种命名方式, 所以为了兼容性考虑, 最好不要通过它去操作原型. Object.setPrototypeOf()Object.setPrototypeOf() 是 ES6 设置原型对象的方法 123456789101112131415let obj = &#123; x: 10&#125;;let option = &#123; x: 20, y: 30, z: 40&#125;;Object.setPrototypeOf(obj, option);obj.x // 10obj.y // 30obj.z // 40// 因原型链访问顺序的优先级, obj.x 为 10 而不是 20, 如 obj 不存在 x 的属性, obj.x 就会为 20. Object.getPrototypeOf()Object.getPrototypeOf(obj) 是 ES6 返回原型对象的方法 Object.keys(), Object.values(), Object.entries()Object.keys() 是 ES5 中遍历属性的方法, ES6 新增了 Object.values(), Object.entries(). Object.values 返回对象自身的(不包含继承的), 可枚举的键值 Object.entries() 返回对象自身的(不包含继承的), 可枚举的键值对数组 对象的拓展运算符ES8 中将数组的拓展运算符引入到了对象中. 解构123let &#123;a, b, ...x&#125; = &#123;a: 1, b:2, c: 3, d: 4&#125;;console.log(x);// &#123;c:3,d:4&#125; 注意: 拓展运算符会复制对象所有未读取的键值对, 所以右侧必须是对象或可转换为对象, 不能为 null 或 undefined 拓展运算符必须置为最后一个位置, 否则会报错 拓展运算符不会复制原型上的方法 克隆对象12let x = &#123;name: 'XingChuan', age: 88&#125;;let cloneObj = &#123; ...x &#125;; 合并对象123let x = &#123;name: 'XingChuan', age: 88&#125;;let y = &#123;job: 'developer'&#125;;let cloneObj = &#123; ...x, ...y &#125;; 拓展运算符表达式1let obj = &#123; ...&#123;x &gt; 1 ? &#123;a: 1&#125; : &#123;&#125; &#125; &#125;; 扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行的. 12345678let runtimeError = &#123; ...a, ...&#123; get x() &#123; throws new Error('thrown now'); &#125; &#125;&#125;; Object.getOwnPropertyDescriptors()ES5 中 Object.getOwnPropertyDescriptor(obj, property) 可以获取对象属性的描述对象. ES8 中 新增了 Object.getOwnPropertyDescriptors(obj) 可以获取对象所有属性的描述对象, 描述对象包括 get 和 set 属性. Null 传导运算符我们要读取对象的一个属性或调用其方法, 为了不报错, 应该先判断对象是否存在, 然后再读取其属性. 如果我们想读取 obj.info.xingchuan.name, 安全的写法应该是下面这样 1let name = obj &amp;&amp; obj.info &amp;&amp; obj.info.xingchuan &amp;&amp; obj.info.xingchuan.name || 'default'; 现在提案中引入了 Null 传导运算符, 简化了写法, 可以写为下面这种方式. 1let name = obj ?. info ?. xingchuan ?. name || 'default'; 参考资料 MDN JavaScript高级程序设计 ECMAScript6入门 JavaScript忍者禁术]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[encodeURI和encodeURIComponent]]></title>
      <url>%2F2017%2F06%2F22%2FJavaScript%2FencodeURI%E5%92%8CencodeURIComponent%2F</url>
      <content type="text"><![CDATA[URL是统一命名的网络资源, 是为了支持网络所有协议使用而诞生的. 需要满足以下 3 个特点: 移植性 (支持各种网络协议) 完整性 (不会丢失数据) 阅读性 (语义化结构) 为了满足以上特点, 设计者引入了转义序列, 以 ACSII 的有限子集转换对任意数据和字符进行编码, 如此的话, 只要支持 ACSII 码的设备都可以根据映射表来使用. JavaScript 中进行编码和解码工作的是 encodeURI/decodeURI 和 encodeURIComponent/decodeURIComponent encodeURI/decodeURI语法: 1encodeURI(URIString); 返回值: 返回以转义序列替换的 URISting 副本 说明: 该方法不会替换 ACSII 中的字母和数字, 也不会替换 ACSII 的标点符号 - _ . ! ~ * &#39; ( ) 编码效果展示: 12345&lt;script type="text/javascript"&gt;console.log(encodeURI("http://www.w3school.com.cn")+ "&lt;br /&gt;");console.log(encodeURI("http://www.w3school.com.cn/My first/"));console.log(encodeURI(",/?:@&amp;=+$#"));&lt;/script&gt; 123http://www.w3school.com.cnhttp://www.w3school.com.cn/My%20first/,/?:@&amp;=+$# 解码: 1decodeURI encodeURIComponent/decodeURIComponent语法: 1encodeURIComponent(URIstring) 返回值: 返回以转义序列替换的 URISting 副本 说明: 该方法不会替换 ACSII 中的字母和数字, 也不会替换 ACSII 的标点符号 - _ . ! ~ * &#39; ( ). ;/?:@&amp;=+$,# 这些用于分割 URL 的标点符号, 会被转义. 编码效果展示: 12345&lt;script type="text/javascript"&gt;console.log(encodeURIComponent("http://www.w3school.com.cn"));console.log(encodeURIComponent("http://www.w3school.com.cn/p 1/"));console.log(encodeURIComponent(",/?:@&amp;=+$#"));&lt;/script&gt; 123http%3A%2F%2Fwww.w3school.com.cnhttp%3A%2F%2Fwww.w3school.com.cn%2Fp%201%2F%2C%2F%3F%3A%40%26%3D%2B%24%23 解码: 1decodeURIComponent 参考 HTTP 权威指南 w3cschool]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端工作流-Sublime同步刷新浏览器&分屏操作]]></title>
      <url>%2F2017%2F06%2F22%2Ftools%2F%E5%89%8D%E7%AB%AF%E5%B7%A5%E4%BD%9C%E6%B5%81-Sublime%E5%90%8C%E6%AD%A5%E5%88%B7%E6%96%B0%E6%B5%8F%E8%A7%88%E5%99%A8%26%E5%88%86%E5%B1%8F%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[电脑环境 Mac pro 10.12.5 chrome 浏览器 最近更换了 Mac 本, 在尝试一些提高工作效率的流程和工具, 今天分享一下 sublime 的使用技巧. Sublime 保存浏览器同步刷新安装 Sublime 插件, 不通过 package control 安装, 需要通过 git 克隆, 网友说直接安装的有问题, 具体没有细究. 插件官方地址: https://github.com/alepez/LiveReload-sublimetext3 Mac 安装方法: 执行以下命令: 123cd ~/Library/Application\ Support/Sublime\ Text\ 3/Packages/rm -rf LiveReloadgit clone https://github.com/alepez/LiveReload-sublimetext3 LiveReload 安装插件成功. commond + shift + p 启动 sublime 命令行 (LiveReload:enable/disable plug-ins =&gt; Enable - simple reload) 在谷歌应用商店安装 livereload 插件 在 chrome 点击 livereload 按钮, 图标中间小圆点变成实心即成功.(点击需在你想要同步刷新的页面完成) Mac 同窗口分屏操作win 窗口左右分屏有很方便的 win + 左箭头/右箭头 Mac 其实也有类似功能, 点击窗口左上角最大化按钮, 持续 2s 以上, 即可拖动到左边窗口/右边窗口, 点击现存的窗口即可填充另一边的窗口.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS属性缩写整理]]></title>
      <url>%2F2017%2F05%2F26%2FHTML%26CSS%2FCSS%E5%B1%9E%E6%80%A7%E7%BC%A9%E5%86%99%E6%95%B4%E7%90%86%2F</url>
      <content type="text"><![CDATA[属性缩写可以提高代码编辑效率, 也可以减少冗余代码, 是开发过程中不可或缺的部分. border-width1234border-width: 1px; // 上右下左均1pxborder-width: 1px 2px; // 上下1px 左右2pxborder-width: 1px 2px 3px; // 上1px 左右2px 下3pxborder-width: 1px 2px 3px 4px; // 上1px 右2px 下3px 左1px border-radius1234border-radius: 1px; // 四个角均1pxborder-radius: 1px 2px; // 上左、下右1px 上右、下左2pxborder-radius: 1px 2px 3px; // 上左1px 上右、下左2px 下右3pxborder-radius: 1px 2px 3px 4px; // 上左1px 上右2px 下右3px 下左1px background1234background-color: #000;background-image: url(images/bg.gif);background-repeat: no-repeat;background-position: top right; 简写:1background: #000 url(images/bg.gif) no-repeat top right; font12345font-style: italic;font-weight: bold;font-size: .8em;line-height: 1.2;font-family: Arial, sans-serif; 简写:1font: italic bold .8em/1.2 Arial, sans-serif; border123border-width: 1px;border-style: solid;border-color: #000; 简写:1border: 1px solid #000; margin&amp;padding1234margin-top: 10px;margin-right: 5px;margin-bottom: 10px;margin-left: 5px; 简写:1margin: 10px 5px 10px 5px; 这里主要借鉴 MDN 上的信息, 感觉总结的不是很全面, CSS3 的属性都没有体现, 等有时间再扩充下 CSS3 的属性缩写部分.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SVN基础使用教程]]></title>
      <url>%2F2017%2F05%2F12%2Fworks%2FSVN%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[公司使用 SVN 做代码管理, 之前没有接触过, 网上找了很多教程, 但都没说的很全面. 推荐一个我目前看到比较完整的 SVN 教程. http://www.open-open.com/lib/view/open1432211679708.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[nodetpl模版引擎使用]]></title>
      <url>%2F2017%2F05%2F09%2Fworks%2Fnodetpl%E6%A8%A1%E7%89%88%E5%BC%95%E6%93%8E%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[nodetpl 关键字 &lt;? ?&gt; nodetpl 定界符 $ROOT 模版中 HTML 代码需要包裹在 id 为 $ROOT 的元素中 ROOT 在 script 标签中使用, 相当于 document.getElementById(‘$ROOT’) $SUBROOT 多模版, 子模版 HTML 用 id 为 $SUBROOT 的元素包裹 SUBROOT 多模版, 在子模版 script 标签内使用. $DATA 传入模版中的数据挂载在 $DATA 下 = 纯文本渲染, 放 XSS == HTML, JS 代码会实际渲染 include 引入 tpl 模版 template 多模版, 单模版用 template包裹 main 多模版, 主模版需设置 name=”main” nodetpl.config 配置 nodetpl.get 渲染, 可指定 url nodetpl.render 渲染模版代码, 一般手动拼接 nodetpl.exec 执行模版中的 js 代码 –extname 拓展名, 默认 .tpl –encoding 预编译指定编码 –watch 预编译实时监视 –nostrict 预编译不使用严格模式 起步 Demo引入文件 script 标签引入 1&lt;script src="./js/nodetpl.min.js"&gt;&lt;/script&gt; require 模块化引入 1var nodetpl = require('nodetpl'); 创建模版创建 tpl/test.tpl 123456&lt;h1&gt;&lt;?=@title?&gt;&lt;/h1&gt;&lt;ul&gt; &lt;?for (var i=0; i&lt;@favor.length); i++?) &#123;&gt; &lt;li&gt;&lt;?=@favor[i]?&gt;&lt;/li&gt; &lt;?&#125;?&gt;&lt;/ul&gt; 渲染nodetpl.get 与 nodetpl.render 需要使用 Nginx 或 Apache 代理. 1234567var data = &#123; "title": "个人爱好", "favor": ["足球", "篮球", "乒乓球", "琉璃球"]&#125;;nodetpl.get('tpls/test.tpl', data, function(d)&#123; console.log(d);&#125;); 执行结果1234567&lt;h1&gt;个人爱好&lt;/h1&gt;&lt;ul&gt; &lt;li&gt;足球&lt;/li&gt; &lt;li&gt;篮球&lt;/li&gt; &lt;li&gt;乒乓球&lt;/li&gt; &lt;li&gt;琉璃球&lt;/li&gt;&lt;/ul&gt; nodetpl API nodetpl.config 基本配置, 一般使用默认 nodetpl.get 获取模版或者编译后的模版文件 nodetpl.render 渲染某个文件 nodetpl.exec 执行模版里面的 js 代码 API 参数 nodetpl.config(options) 123456789101112131415nodetpl.config(&#123; base: 'http://www.nodetpl.com/static/tpl/', // 强制指定模板根目录 openTag: '&lt;?', closeTag: '?&gt;', strict: true, map: function(str) &#123; return str; &#125;, beforeCompile: function(html) &#123; return html; &#125;, afterCompile: function(html) &#123; return html; &#125;&#125;); base：模板所在的根路径，可以省略。若配置该参数，则使用 .get() 方法填写的路径会相对于该路径进行查找 openTag：模板定界符开始标签，默认为：&lt;? closeTag：模板定界符结束标签，默认为：?&gt; strict：是否开启严格模式，默认开启 map：传递一个解析函数（转换器），用来解析其他语法，例如 php、jsp 等 beforeCompile：编译前的处理函数 afterCompile：编译后的处理函数 nodetpl.get(url, [data, ] callback) url 模版文件地址 data 传入的数据, 值为 false 则暂缓渲染, 传入 NodeTplClass 实例作为 callback 的参数, 需要渲染时, 使用 tpl.render(data). callback 接收渲染后的 html 作为参数 nodetpl.render(tplcontent[, data][, callback]); tplcontent 需要渲染的 HTML 结构 data 传入的数据 callback 接收渲染后的 HTML 结构为参数 nodetpl.exec(content); 执行 HTML 结构中的 JavaScript 代码. nodetpl 预编译需要安装 node 模块: 1npm i -g nodetpl 使用语法: 1nodetpl &lt;path&gt; --extname &lt;extname&gt; --encoding &lt;encoding&gt; --nostrict --watch &lt;path&gt;：必选，模板文件的路径，或模板所在的目录路径 --extname：可选，模板文件的扩展名，默认为 .tpl --encoding：可选，模板的编码格式，默认为 utf-8，可选值：utf-8、gbk --nostrict：可选，启用非 strict 模式，不推荐传递该参数 --watch：可选，是否监控文件变化，默认为 false，当传递该参数时，修改模板内容会同步自动编译]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Web前端面试总结_2017.07]]></title>
      <url>%2F2017%2F05%2F07%2Fworks%2FWeb%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93-2017-05%2F</url>
      <content type="text"><![CDATA[原文链接: https://github.com/Xing-Chuan/blog/blob/master/works/Web前端面试总结-2017-05.md 面试告一段落, 把自己的面试体验整理一下, 给各位提供一下备战的思路. 声明: 以下皆是个人观点, 仅供参考之用. 简历投递前期为了解自身短板, 可以海投一些试试. 不建议长期海投简历,对用人单位简历筛选和你自身都没什么好处.投简历之前最起码要关注以下几点(薪资范围, 公司位置, 职位要求, 是否为培训机构冒充招聘). 前端职位类型现在前端招人分的挺细了, 下面是我印象中几种职位. Web 前端开发工程师 (页面重构方面和JS逻辑方面) HTML5 前端开发工程师 (一般都是移动端或者 canvas 做游戏) WebGL 前端开发工程师 (这是数据可视化的, 三维实时展现数据) APP 前端开发工程师 (应该混合 App 开发、RN 都算这里面) 微信小程序、公众号开发 前端开发工程师 (我是不准备选, 可能小公司会专门找人做这个) PHP/JAVA 前端开发工程师 (公司可能前后端没有完全分离) React 前端开发工程师 (做大项目的居多, 业务逻辑复杂) Nodejs 工程师 (写服务端的, Node 处理高并发很优秀, CNode 社区很多招的) 公司类型每个公司的技术栈是不同的, 招人也会倾向于你简历的技术栈. 稳健型 使用 jQuery 等历史悠久类库, 一般不用 3 大框架, 重视 JQuery, JS, HTML + CSS 基础和实际效果实现 潮流型 普遍大公司或者中小型公司, 会使用 Angular, Vue, React 等框架, 会问框架的具体使用和下面我写的那些东西, 原理偏多,很少问 jQuery. 基础型 页面重构&amp;效果呈现, CSS3 + HTML5, 基础 JS 能力, 招你可能就是写页面或者活动页之类的 偏门型 招你专做小程序&amp;微信相关东西, 或者WebGL,D3之类的做数据化展示,比较高深,恩.. 疯癫型 不知所云, 把面试当公司宣传活动或者拿面试题打击你, 我没遇到过, 有人遇到过, 是我的话, 离远点, 只是个人建议. 不管到哪里, 基础都很重要, 恩, 随机应变也很重要. 面试官考教流程 你的笔试题, 根据其做延伸. 你的简历, 技术栈、工作外学习情况、项目经验. 第一页很重要, 最好都能掌握, 有亮点更好. 面试官额外的延展的知识点, 随机问,看你运气和积累(一般会提及到 ES6、解决实际问题的方法、数据结构与算法都有可能). 应对 刷题, 各种基础题会帮你快速回忆起来, 比你看书快, 如果基础不好的话, 看书好好学学吧. 简历上自己写的东西, 要能说出来. 积累, 每次面试不成功就回来填坑吧, 还是有掌握不到位的. 我觉得能坚持下来的话, 找工作只是时间问题. 面试着重点分类根据公司业务不同, 着重点不一样, 公司能把你简历挑出来, 就说明有用人单位感兴趣的部分. 可能你写的是 熟练使用 Vue, 公司也是这个技术栈. 可能你知识写的全面, 公司想面面你实际掌握怎么样. 可能你项目写的贴合用人单位需要, 比如都是做后台管理的. 框架问题: (Vue 举例, 3框架实质问题差不多, 具体有些差异) 封装过哪些组件?有自己写过 UI 组件吗? 什么是 MVVM , 和 MVC 是什么区别, 原理是什么? 父子组件怎么通信的? 兄弟组件怎么通信的? 生命周期有哪些, 怎么用? Vue 全家桶都用过哪些?具体怎么用? HTML5 + CSS3 盒子模型 如何给未知宽高的图片垂直居中对齐? 有几种方法? 移动端的 rem 布局. 前端可以做哪些优化, 或问你 SEO, 基本都问. 清除浮动方式和原理, 基本都问. 几种方式? 原理? 为什么要用伪元素? 具体代码怎么写,为什么这么写? 清除浮动就会涉及到 BFC 的问题. 给你实际页面例子, 让你口述布局或手写实现细节, 可以使用几种方法, 怎么写兼容性好, 拓展性好. 具体 API 哪个 CSS 版本的? CSS3 新增了哪些 API? 可能问你哪些 API 是 CSS 哪个版本的? 兼容性怎么样. CSS hack 是什么? 包含什么? 怎么处理兼容性问题? HTML5 新增了哪些 API? 哪些比较常用? 用来做什么? 实际怎么用? cookie, session, localStrorage, sessionStorage 区别, 具体怎么用代码去操作? JavaScript 变量声明提升的问题. 闭包的原理, 闭包的各种题, 基本都问. DOM2 事件流, 冒泡和捕获问题? this 指向问题, 一般都是在笔试题里, 拿着问你, 问的比较多. call 和 apply 区别? 有的还会加问 bind? jQuery 获取复选框选中状态, 为什么要用 prop 方法? 面向对象编程中的继承问题, 原型链问题在笔试题里比较常见. jQuery API , 各种操作 DOM 用法, 还有一些新的 API, 这种在不用 3 大框架的公司会问的很详细. 可能有些考算法结构的, 可以了解一下, 一般前端掌握的很少. Ajax 基本都问, 问的细节可能不同, 比如 get 和 post 有什么区别? 数组的方法 - es6 以下基本都能熟练使用, 应该会加分不少 字符串的方法 - 拼接, 截取, 带些正则 数组去重问的挺多的(解法很多, ES6 有很多简短写法) ES6 的 Promise , 很多都会问. 如果公司用框架或者你写了, 还会问你 Class. var, let, const区别, 问的多. 栈和队列结构, 有的会问. 跨域问题: 同源策略, 解决方案, 解决原理(比如 jsonp 的原理), 这里都是高发区. 其他 url 解析过程. 缓存的原理. TCP 3次握手. HTTP 协议. 看过哪些技术书籍? 可能直接问你书里的东西, 个人觉得至少 2 本以上储备量吧. 项目问你用过什么技术, 用过哪些插件解决什么问题之类的, 了解一下你的技术栈. 那些开发用的插件和技术名词最好回想, 整理一下, 不要面试的时候蒙了. 负责什么模块? 使用到的技术? 遇到过什么难题? 怎么解决的? 工作之外的学习情况? 一般会从侧面了解一下 技术部门架构 按照业务线来划分部门, 每个部门配置(运营, 产品, UI, 前端, 服务端, 安卓, ios), 工作效率高, 前端 1-4 人或更多都有可能, 看业务量. 按照技术种类划分部门, 交流成本较高. 恩, 还有可能前端只有 1 或 2 人. 技术人员配置主要还是看公司业务量的多寡, 和公司产品类型. 开发平台很久没更新了, 今天说说工作中的开发平台. 如果开发的是 App ,那我们针对的是某一个版本号的开发. 推陈出新需要一个过程, 所以就有开发平台这种流程出现. 一个版本从需求讨论, 一直到开发完成上线, 大致经过以下几个过程. 需求讨论(技术可行性, 时间需求等) 需求讲解(产品告诉技术我们这次需要多什么) 前后端约定接口形式(一般都有通用形式的要求, 但具体参数和返回值需要具体商议) 前端, 后端, 客户端分别开发 前后端联调(测试交互功能) 提测(交于QA测试功能) QA测试(禅道等bug管理平台, bug 指向人修改 bug) 预上线(模拟真实线上环境) 上线(预上线一切正常就可以上线了) 这其中涉及到几处环境: 研发环境 测试环境 预上线环境 线上环境 想理解几套环境的差异, 需要了解 host 这个概念. 123127.0.0.1 www.baidu.com 指向本地10.10.10.111 www.baidu.com 指向局域网服务器45.23.26.23 www.baidu.com 指向网络独立IP host 可以改变域名指向的服务器 IP 地址, 线上的各种网站也是需要在域名控制台配置域名指向的, 所以你想办网站, 不只是要有域名, 还要有一台拥有独立 IP 地址的服务器. 我们通过切换 host 的指向, 改变资源(js,css,images)的指向, 可以自由切换到不同的服务器上去, 基于这一点, 形成开发平台的概念. 想看网上域名指向何处, 可以搜一下关键词 ping]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端构建mock-server的几种方式]]></title>
      <url>%2F2017%2F05%2F02%2Fworks%2F%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BAmock-server%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[这里收集一些用来构建 mock-server 的方式: 什么是 mock-server目前流行的前后端分离开发方式, 前后端并行开发, 前端部分前期是没有 API 接口可用的, 所以需要按照约定的数据格式构建 mock-server, 尽量保持真实的开发环境. mock-server 实现方式 Mock.js，仅用于单一数据模拟，没有生成文档的功能 Swagger Editor npm install 时候的几个包弄不定, 文档编写难度大 FMS - FMS，轻量级， 使用数据模拟时还有些别扭 RAP v0.11，结合了文档、Mock.js、可视化、Rest、接口过渡、文档修改提醒、支持本地部署 json-server 基于 nodejs 的 mock-server, 支持 CRUD, 支持动态参数, 2分钟创建 博主只使用过 json-server , 作为一个前端, 我认为这款 GitHub 上 21K star 的工具已经足够用了 :happy .等有时间翻译出来一篇 json-server 的中文文档.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[nodeName、nodeType和nodeValue的区别]]></title>
      <url>%2F2017%2F05%2F02%2FJavaScript%2FnodeName%E3%80%81nodeType%E5%92%8CnodeValue%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[nodeNamenodeName 包含节点的名称 元素节点 -&gt; 标签名称 属性节点 -&gt; 属性名称 文本节点 -&gt; #text 文档节点 -&gt; #document PS: nodeName 所包含的 XML 元素的标签名称永远是大写的. nodeTypenodeType 属性可返回节点的类型 常用的节点类型: 元素类型 节点类型 元素 element 1 属性 attr 2 文本 text 3 注释 comments 8 文档 document 9 nodeValuenodeValue 属性对于文档节点和元素节点是不可用的. 对于文本节点 -&gt; nodeValue 为文本 对于属性节点 -&gt; nodeValue 为属性值]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS事件的三个阶段与事件委托的原理]]></title>
      <url>%2F2017%2F05%2F02%2FJavaScript%2FJS%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E7%9A%84%E5%8E%9F%E7%90%86%2F</url>
      <content type="text"><![CDATA[事件阶段DOM2级事件规定的事件流包括三个阶段，分别是：事件捕获阶段，处于目标阶段和事件冒泡阶段. 事件冒泡 事件开始时由最具体的元素(文档中嵌套最深的那个节点)接收，然后逐级向上（一直到文档） 12345&lt;div id = "div"&gt; &lt;span id="span"&gt; &lt;a id="aTag"&gt;事件测试&lt;/a&gt; &lt;/span&gt;&lt;/div&gt; 123456789101112document.getElementById("aTag").addEventListener('click',aTag);document.getElementById("span").addEventListener('click',span);document.getElementById("div").addEventListener('click',div);function aTag(e) &#123; alert("点击的是a标签");&#125;function span(e) &#123; alert("点击的是span标签");&#125;function div(e) &#123; alert("点击的是div标签");&#125; 123451)先打印出：点击的是a标签2) 再打印出：点击的是span标签3) 最后打印出：点击的是div标签 事件捕获 事件捕获与事件冒泡事件流正好相反的顺序，事件捕获的事件流是最外层逐级向内传播，也就是先document，然后逐级div标签 ， span标签 , a标签. 改写上面的 js 代码: 123document.getElementById("div").addEventListener('click',div,true);document.getElementById("aTag").addEventListener('click',aTag,true);document.getElementById("span").addEventListener('click',span,true); 第三个参数设置为 true 为捕获事件, 默认为 false 是冒泡事件 事件委托事件委托可以避免对每个节点添加事件监听, 我们可以利用冒泡原理, 将事件绑定到父元素上. 以下需要对父元素做事件委托: 很多兄弟元素需要绑定同一个事件时 子元素需要动态插入或删除时 事件委托的原理当我们进行事件委托时, 事件监听器会分析从子元素冒泡上来的事件，找到是哪个子元素的事件. 当我们有如下文档结构时: 12345678&lt;ul id="parent-list"&gt; &lt;li id="post-1"&gt;Item 1&lt;/li&gt; &lt;li id="post-2"&gt;Item 2&lt;/li&gt; &lt;li id="post-3"&gt;Item 3&lt;/li&gt; &lt;li id="post-4"&gt;Item 4&lt;/li&gt; &lt;li id="post-5"&gt;Item 5&lt;/li&gt; &lt;li id="post-6"&gt;Item 6&lt;/li&gt;&lt;/ul&gt; 当子元素的事件冒泡到父 ul 元素时，你可以检查事件对象的 target 属性，捕获真正被点击的节点元素的引用。下面是一段 JavaScript 代码，演示了事件委托的过程： 12345document.getElementById("parent-list").addEventListener('click', function (e) &#123; if (e.target &amp;&amp; e.target.nodeName == 'LI') &#123; console.log(`List item,$&#123;e.target.id&#125;, was clicked!`) &#125; &#125;) 执行过程: 给父元素添加事件监听器 事件触发时, 检查事件来源 如果触发事件的是 li 元素, 执行对应代码, 否则不执行]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Chrome插件-Vimium(键盘替代鼠标操作)]]></title>
      <url>%2F2017%2F04%2F29%2Fcomputer%2FChrome%E6%8F%92%E4%BB%B6-Vimium(%E9%94%AE%E7%9B%98%E6%9B%BF%E4%BB%A3%E9%BC%A0%E6%A0%87%E6%93%8D%E4%BD%9C)%2F</url>
      <content type="text"><![CDATA[有过Linux经验的朋友肯定用过Vi和Vim,这款Chrome插件提供类似简短键盘命令控制浏览器操作,学会基本可以摆脱鼠标了 安装途径: 有梯子的,在谷歌浏览器应用商店安装 没梯子的,这里我提供下应用ID : vimium/dbepggeogbaibhgnhhndojpepiihcmeb,可以在这个网站下载 快捷键使用ctrl+/可以查看快捷键,不过是全英文的 快捷键很多,常用的不是很多,以下可以作为查找之用,想用什么功能了,来这里找找 此插件配合鼠标手势使用,效果更佳 基本操作:j: 页面向下移动k：页面向上移动h：页面向左移动l：页面向右移动zH：一直移动到左部zL:一直移动到右部gg：跳转到页面的顶部G：跳转到页面的底部d：向下翻页u：向上翻页r：重新载入该页（Reload）gs：查看页面源代码yy：拷贝当前页面的URL到剪贴板yf：拷贝页面上某一个URL到剪贴板gu：跳转到父页面 i：输入模式（进入输入模式后，命令不起作用,按Esc退出输入模式）gi：将焦点集中到第一个输入框 f：在当前的页面打开一个新的链接。F：在新的页面打开一个新的链接。b：在当前页打开一个书签。（输入部分网址会自动进行搜索）B：在新的标签页打开一个书签(如果你书签很多,很有用,可以直接搜索书签) 查找模式：/ : 查找(浏览器都支持Ctrl+F5查找,这个没什么用)n: 向下查找匹配内容N：向上查找匹配内容 导航历史：H：回退上一个历史页面（相当于浏览器中的向左箭头）L：回到下一个历史页面（相当于浏览器的向右箭头） 标签页操作：K，gt：跳转到右边的一个标签页J，gT：跳转到左边的一个标签页t：创建一个新的标签页x：关闭当前的标签页X：恢复刚刚关闭的标签页？：显示命令的帮助提示（Shift+/） 一些补充Chrome浏览器自身也是有快捷键的,比如 F6:自动选中当前url 快捷键很多,不过Chrome快捷键大多是组合快捷键,不是很好用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[电脑启动篇]]></title>
      <url>%2F2017%2F04%2F26%2Fcomputer%2F%E7%94%B5%E8%84%91%E5%90%AF%E5%8A%A8%E7%AF%87%2F</url>
      <content type="text"><![CDATA[折腾电脑好多年, 最喜欢的就是装各种软件.是时候分享一下自己觉得好用的软件了, 都是干货. 电脑环境: Window 7 64bit 还没有机会用 MAC 本, 所以暂时推荐的都是 window 下的软件,目前也是国内最大众的电脑系统, 这几年 Linux 也是挺火的呢 喜欢装软件的, 或者不注意保养自己电脑的人, 一般都会被开机加载一堆软件所困扰.博主固态 SSD 也 Hold 不住. Quick Startup下面这是界面样式: 可以自定义延时执行时间, 把不需要立即使用的都放到后面执行,这样电脑就不会开机卡几分钟之后才能用了. 不需要的启动项直接禁用或删除, 这点一般的管理软件也都有提供. 这款软件特点就是可以自定义软件延时执行的时间.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[域名的选择与解析设置]]></title>
      <url>%2F2017%2F04%2F26%2Flinux%2F%E5%9F%9F%E5%90%8D%E7%9A%84%E9%80%89%E6%8B%A9%E4%B8%8E%E8%A7%A3%E6%9E%90%E8%AE%BE%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[最近又念想着换个域名, 搜索了半天域名, 发现都被注册掉了, 所以这想法就暂时流产了. 想着没有写过关于域名的文章, 所以补充一下. 域名的分类 国内域名 .cn 国际域名 .com .net .org .site 域名的选择国内域名和服务器是有特殊环境的,国内的域名和服务器都需要备案在册的,不得所以随意更改, 如果哪天你的服务商倒闭了,追回损失就是一件麻烦事. 当然, 如果你上传了反动思想、少儿不宜的内容, 随时可能被查水表, :happy 个人选择:长期持有的话, 我觉得哪种都无所谓,域名的作用只是为了让人们方便的访问,而且各个服务商提供的域名续费费用每年都是差不多的, 首年特惠 8元/年的 .site, 可能续费比 .com的都贵 企业选择:商业型, 建议选 .com, 世界注册最多,辨识度高非盈利组织/机构, 建议选 .org机构/办事处, 建议选 .net 投资选择:建议不要在万网买, 转出很麻烦.国内可以在易名, 爱名网注册, 国外可以在 goDaddy 注册 PS: 建议注册国际域名, 不用备案, 比如在万网注册国际域名, 提交实名认证就好了, 可以在阿里云手机端用支付宝快捷实名认证, 很方便. 域名的解析设置等你拿到域名了, 就需要设置域名解析了. 解析可能有几种指向: 一个免费的二级域名空间, 但是域名很长 你持有的服务器 IP 地址 提供邮箱服务的服务器 IP 地址 几种常用的解析方式: 解析方式有很多, 但是常用的就几种 a 解析, 指向 IP 地址 如果是自己持有的服务器, 直接设置 a 解析就可以了, 因为 IP 地址是不变的 CNAME 解析, 指向域名地址 如果是免费的二级域名, 需要用 CNAME 指向, 如果访问你指向的免费的二级域名也要跳转到你自己的域名,请在网站根目录创建 CNAME 文件(大写, 无后缀名) MX 解析, 指向邮箱服务器地址 一般都是不会自己搭建邮箱服务器的, 企业为了保密才需要, 个人的话我推荐使用阿里云企业邮箱, 或者腾讯企业邮箱就可以了.注册企业邮箱账户的时候, 会给你两条 MX 指向的文本信息, 你设置到自己域名的解析里面就可以用了.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[每日一句]]></title>
      <url>%2F2017%2F04%2F21%2Fdayily%2FREAMME%2F</url>
      <content type="text"><![CDATA[2017-4-21 12:55:36 Everyone has his inherent ability which is easily concealed by habits, blurred by time, and eroded by laziness. 每个人都有潜能，只是很容易被习惯所掩盖，被时间所迷离，被惰性所消磨。 2017-4-23 14:55:57 Don’t make promises when you’re joyful. Don’t reply when you’re sad. Don’t make decisions when you’re angry. ** 别在喜悦时承诺，别在悲伤时回答，别在愤怒时决定。 2017-4-25 20:30:06 The shortest distance between two people is a smile. 人与人之间最短的距离是微笑。 2017-4-26 17:15:53 Never regret. If it’s good, it’s wonderful. If it’s bad, it’s experience. 不必遗憾。若是美好，叫做精彩。若是糟糕，叫做经历。 2017-4-27 11:10:00 It doesn’t matter if the guy is perfect or the girl is perfect, as long as they are perfect for each other. - Good Will Hunting 那个小伙子是否完美，或者那个姑娘是否完美都不重要，只要他们能珠联璧合。——《骄阳似我》 2017-5-1 10:47:14 People who agonize don’t act. People who act don’t agonize.– Pierre Sauvage 痛苦的人不采取行动，采取行动的人不痛苦。– 皮尔·索瓦格 2017-5-2 17:28:01 Imperfection is beauty, madness is genius and it’s better to be absolutely ridiculous than absolutely boring. - Marilyn Monroe 不完美也是一种美，疯狂也是天分，荒唐总好过无聊。——玛丽莲梦露 附一: 只有疯狂到认为自己能改变世界的人，才能真正的改变世界。——乔布斯 2017-5-3 21:42:11 Don’t worry too much about the ambiguous future; just make the effort for the explicit present. 不为模糊的未来过分担忧，只为眼前的现在奋发图强。 2017-5-6 22:54:12 Don’t say you don’t have enough time.You have exactly the same number of hours per day that were given to Helen Keller, Louis Pasteur, Michelangelo, Thomas Jefferson and Albert Einstein. 不要说你时间不够，你每天被付予的小时数和海伦凯勒、巴士德、米开朗基罗、杰弗逊、及爱因斯坦完全一样。 我荒废了时间，时间便把我荒废了。——莎士比亚 2017-5-7 22:32:55 Death is nothing, but to live defeated and inglorious is to die daily. - Napoleon Bonaparte 死不算什么，但失败或不光采的活着如同每天死亡。——拿破仑 2017-5-8 21:29:36 Knowledge will give you power, but character respect. - Bruce Lee 知识给你力量，品格给你别人的尊敬。——李小龙 2017-5-9 22:02:11 Don’t lie to people who trust you, and don’t trust people who lie to you. 不要对相信你的人撒谎，也不要相信对你撒谎的人。 2017-5-10 20:29:28 The higher we soar the smaller we appear to those who cannot fly. 我们飞得越高在那些不能飞的人眼中的形象就越渺小。 2017-5-11 16:26:57 Change your life today. Don’t gamble on the future, act now, without delay. 改变从今天开始. 不要把期望放在明天. -西蒙·波娃 2017-5-14 20:11:40 An intellectual is a man who says a simple thing in a difficult way; an artist is a man who says a difficult thing in a simple way. 一个知识分子把一件简单的事描述的很复杂, 艺术家则相反. 2017-05-26 今天不写英文了, 在编程随想的模块看到一句话, 分享一下. 1判断一个人的人品, 不是看他好起来做什么好事, 而是看他坏起来不做什么坏事. 2017-06-01 The great pleasure in life is doing what people say you cannot do. 人生最大的快乐是做到别人认为你做不到的事情 2017-06-21 = = 以后还是用中文写感想吧 2017-06-22 别人家的和自己家的事要拎得清, 你和朋友可能同吃同住同上课, 但你们的出路和未来起步点都是不同的.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Github README]]></title>
      <url>%2F2017%2F04%2F18%2FREADME%2F</url>
      <content type="text"><![CDATA[各位好: 这里是 XingChuan 的博客,【行川草庐】. 博客地址: http://www.jixingchuan.com/ 这里是我博客的源文件, 你可以免费使用. 你的 star 是我持续开源的动力.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Javascript代码编程规范-Airbnb]]></title>
      <url>%2F2017%2F04%2F04%2Fworks%2FJavascript%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83-Airbnb%2F</url>
      <content type="text"><![CDATA[截止到本文发布,Airbub规范在GitHub上已经5万颗星了. 块级作用域（1）let取代varES6提出了两个新的声明变量的命令： let 和 const 。其中， let 完全可以取代 var ，因为两者语义相同，而且 let 没有副作用。1234567'use strict';if (true) &#123;let x = 'hello';&#125;for (let i = 0; i &lt; 10; i++) &#123;console.log(i);&#125; 上面代码如果用 var 替代 let ，实际上就声明了两个全局变量，这显然不是本意。变量应该只在其声明的代码块内有效， var 命令做不到这一点。var 命令存在变量提升效用， let 命令没有这个问题。 12345'use strict';if(true) &#123;console.log(x); // ReferenceErrorlet x = 'hello';&#125; 上面代码如果使用 var 替代 let ， console.log 那一行就不会报错，而是会输出 undefined ，因为变量声明提升到代码块的头部。这违反了变量先声明后使用的原则。所以，建议不再使用 var 命令，而是使用 let 命令取代。（2）全局常量和线程安全在 let 和 const 之间，建议优先使用 const ，尤其是在全局环境，不应该设置变量，只应设置常量。这符合函数式编程思想，有利于将来的分布式运算。 12345678// badvar a = 1, b = 2, c = 3;// goodconst a = 1;const b = 2;const c = 3;// bestconst [a, b, c] = [1, 2, 3]; const 声明常量还有两个好处，一是阅读代码的人立刻会意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误。所有的函数都应该设置为常量。长远来看，JavaScript可能会有多线程的实现（比如Intel的River Trail那一类的项目），这时 let 表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全。字符串静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。 123456789// badconst a = &quot;foobar&quot;;const b = &apos;foo&apos; + a + &apos;bar&apos;;// acceptableconst c = `foobar`;// goodconst a = &apos;foobar&apos;;const b = `foo$&#123;a&#125;bar`;const c = &apos;foobar&apos;; 解构赋值使用数组成员对变量赋值时，优先使用解构赋值。 123456const arr = [1, 2, 3, 4];// badconst first = arr[0];const second = arr[1];// goodconst [first, second] = arr; 函数的参数如果是对象的成员，优先使用解构赋值。 123456789101112// badfunction getFullName(user) &#123;const firstName = user.firstName;const lastName = user.lastName;&#125;// goodfunction getFullName(obj) &#123;const &#123; firstName, lastName &#125; = obj;&#125;// bestfunction getFullName(&#123; firstName, lastName &#125;) &#123;&#125; 如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。 123456789// badfunction processInput(input) &#123;return [left, right, top, bottom];&#125;// goodfunction processInput(input) &#123;return &#123; left, right, top, bottom &#125;;&#125;const &#123; left, right &#125; = processInput(input); 对象单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。 123456789101112// badconst a = &#123; k1: v1, k2: v2, &#125;;const b = &#123;k1: v1,k2: v2&#125;;// goodconst a = &#123; k1: v1, k2: v2 &#125;;const b = &#123;k1: v1,k2: v2,&#125;; 对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用 Object.assign 方法。 123456789// badconst a = &#123;&#125;;a.x = 3;// if reshape unavoidableconst a = &#123;&#125;;Object.assign(a, &#123; x: 3 &#125;);// goodconst a = &#123; x: null &#125;;a.x = 3; 如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。 12345678910111213// badconst obj = &#123;id: 5,name: &apos;San Francisco&apos;,&#125;;obj[getKey(&apos;enabled&apos;)] = true;// goodconst obj = &#123;id: 5,name: &apos;San Francisco&apos;,[getKey(&apos;enabled&apos;)]: true,&#125;; 上面代码中，对象 obj 的最后一个属性名，需要计算得到。这时最好采用属性表达式，在新建 obj 的时候，将该属性与其他属性定义在一起。这样一来，所有属性就在一个地方定义了。另外，对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。 1234567891011121314151617var ref = &apos;some value&apos;;// badconst atom = &#123;ref: ref,value: 1,addValue: function (value) &#123;return atom.value + value;&#125;,&#125;;// goodconst atom = &#123;ref,value: 1,addValue(value) &#123;return atom.value + value;&#125;,&#125;; 数组使用扩展运算符（…）拷贝数组。 123456789// badconst len = items.length;const itemsCopy = [];let i;for (i = 0; i &lt; len; i++) &#123;itemsCopy[i] = items[i];&#125;// goodconst itemsCopy = [...items]; 使用Array.from方法，将类似数组的对象转为数组。 12const foo = document.querySelectorAll(&apos;.foo&apos;);const nodes = Array.from(foo); 函数立即执行函数可以写成箭头函数的形式。 123(() =&gt; &#123;console.log(&apos;Welcome to the Internet.&apos;);&#125;)(); 那些需要使用函数表达式的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了this。 12345678910// bad[1, 2, 3].map(function (x) &#123;return x * x;&#125;);// good[1, 2, 3].map((x) =&gt; &#123;return x * x;&#125;);// best[1, 2, 3].map(x =&gt; x * x); 箭头函数取代 Function.prototype.bind ，不应再用self/_this/that绑定this。 12345678910// badconst self = this;const boundMethod = function(...params) &#123;return method.apply(self, params);&#125;// acceptableconst boundMethod = method.bind(this);// bestconst boundMethod = (...params) =&gt; method.apply(this,params); 简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。 123456// badfunction divide(a, b, option = false ) &#123;&#125;// goodfunction divide(a, b, &#123; option = false &#125; = &#123;&#125;) &#123;&#125; 不要在函数体内使用arguments变量，使用rest运算符（…）代替。因为rest运算符显式表明你想要获取参数，而且arguments是一个类似数组的对象，而rest运算符可以提供一个真正的数组。 123456789// badfunction concatenateAll( ) &#123;const args = Array.prototype.slice.call(arguments);return args.join(&apos;&apos;);&#125;// goodfunction concatenateAll(...args) &#123;return args.join(&apos;&apos;);&#125; 使用默认值语法设置函数参数的默认值。 1234567// badfunction handleThings(opts) &#123;opts = opts || &#123;&#125;;&#125;// goodfunction handleThings(opts = &#123;&#125;) &#123;// ... }Map结构注意区分Object和Map，只有模拟现实世界的实体对象时，才使用Object。如果只是需要 key: value 的数据结构，使用Map结构。因为Map有内建的遍历机制。 12345678910let map = new Map(arr);for (let key of map.keys()) &#123;console.log(key);&#125;for (let value of map.values()) &#123;console.log(value);&#125;for (let item of map.entries()) &#123;console.log(item[0], item[1]);&#125; Class总是用Class，取代需要prototype的操作。因为Class的写法更简洁，更易于理解。 1234567891011121314151617181920// badfunction Queue(contents = []) &#123;this._queue = [...contents];&#125;Queue.prototype.pop = function( ) &#123;const value = this._queue[0];this._queue.splice(0, 1);return value;&#125;// goodclass Queue &#123;constructor(contents = []) &#123;this._queue = [...contents];&#125;pop() &#123;const value = this._queue[0];this._queue.splice(0, 1);return value;&#125;&#125; 使用 extends 实现继承，因为这样更简单，不会有破坏 instanceof 运算的危险。 12345678910111213141516// badconst inherits = require(&apos;inherits&apos;);function PeekableQueue(contents) &#123;Queue.apply(this, contents);&#125;inherits(PeekableQueue, Queue);PeekableQueue.prototype.peek = function( ) &#123;return this._queue[0];&#125;// goodclass PeekableQueue extends Queue &#123;peek() &#123;return this._queue[0];&#125;&#125; 模块首先，Module语法是JavaScript模块的标准写法，坚持使用这种写法。使用 import 取代 require 。 1234567// badconst moduleA = require(&apos;moduleA&apos;);const func1 = moduleA.func1;const func2 = moduleA.func2;// goodimport &#123; func1, func2 &#125; from &apos;moduleA&apos;;使用 export 取代 module.exports 。 12345678910111213141516// commonJS的写法var React = require(&apos;react&apos;);var Breadcrumbs = React.createClass(&#123;render() &#123;return &lt;nav /&gt;;&#125;&#125;);module.exports = Breadcrumbs;// ES6的写法import React from &apos;react&apos;;const Breadcrumbs = React.createClass(&#123;render() &#123;return &lt;nav /&gt;;&#125;&#125;);export default Breadcrumbs 如果模块只有一个输出值，就使用 export default ，如果模块有多个输出值，就不使用 export default ，不要 export default 与普通的 export 同时使用。 不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default）。 1234// badimport * as myObject &apos;./importModule&apos;;// goodimport myObject from &apos;./importModule&apos;; 如果模块默认输出一个函数，函数名的首字母应该小写。 123function makeStyleGuide( ) &#123;&#125;export default makeStyleGuide; 如果模块默认输出一个对象，对象名的首字母应该大写。 12345const StyleGuide = &#123;es6: &#123;&#125;&#125;;export default StyleGuide;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[怎么复制Window中CMD命令行中的内容]]></title>
      <url>%2F2017%2F02%2F04%2Fexperiences%2F%E6%80%8E%E4%B9%88%E5%A4%8D%E5%88%B6Window%E4%B8%ADCMD%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9%2F</url>
      <content type="text"><![CDATA[Git bash和shell命令条默认都是可以复制内容的,Window的命令条却不行,有时候真的很麻烦. 在选项卡中把编辑模式改成快速编辑模式就可以了,只是不容易找到设置界面. 把鼠标放在CMD面板的上方的半透明条，右击出来右键菜单,点击”属性” 在编辑选项中选中”快速编辑模式”,”确定”保存设置 选中内容后,使用enter按键自动保存到剪切板,也可以右键菜单手动复制、粘贴]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PC端实现在线看美剧的方法]]></title>
      <url>%2F2017%2F02%2F01%2Fcomputer%2FPC%E7%AB%AF%E5%AE%9E%E7%8E%B0%E5%9C%A8%E7%BA%BF%E7%9C%8B%E7%BE%8E%E5%89%A7%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[本人喜欢看些美剧, 但目前片源是个问题, 你可以在 PC 端找到很多可下载的最新资源.它们都是需要下载的, 不能够在线观看, 但手机端很多优秀的应用是可以提供在线观看服务. 所以有了现在这篇文章, 原理并不难, 借助 Android 模拟器实现. 推荐两款模拟器 Bluestacks 夜神模拟器 这两款是我使用过, 感觉还不错的. 需要软件 人人视频 人人视频之前叫做人人美剧, 是国内比较火的美剧 App.你也可以安装其他提供美剧在线服务的 App.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端可以做哪些优化]]></title>
      <url>%2F2017%2F01%2F26%2Fworks%2F%E5%89%8D%E7%AB%AF%E5%8F%AF%E4%BB%A5%E5%81%9A%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%2F</url>
      <content type="text"><![CDATA[网页打开的延时, 页面操作的流畅度, 就是一个网站的生命. 我们站在前端的角度, 都可以做哪些优化呢? 来自谷歌的 Web 优化实践 避免资源 404 请求 避免CSS @import import 依赖关系, 加载完一个再加载另一个 避免使用document.write 都用 HTML 来调用, 使用 document.write 浏览器还需要运行 JS 解析器分析下面要做什么 合并、压缩 CSS, JS文件 精灵图整合图像, 字体图标代替部分图片 延迟 JavaScript 加载 启用Keep-Alive 将小的CSS和JavaScript代码内嵌到HTML中 利用浏览器缓存不长变更的资源 尽量减少DNS查询次数 尽量减少重定向 优化样式表和脚本的顺序 避免JavaScripts阻塞渲染 缩小原始图像 指定图像尺寸 来自雅虎的 Web 优化实践 内容优化 避免资源 404 请求 减少 HTTP 请求 减少 DNS 查找 减少重定向 预加载组件 延迟加载脚本和内容 Ajax 缓存文件资源 减少 DOM 元素数量 根据域名划分页面内容 最小化 iframe 数量 服务器优化 使用 CDN 内容分发网络 添加Expires或Cache-Control信息头 Gzip 压缩 设置 Etag , 判断服务器与浏览器缓存中内容的一致性 提前刷新缓冲区 对Ajax请求使用GET方法 避免空的 src cookie 的优化 减少 cookie 的大小 针对Web组件使用域名无关的Cookie ( 突破 cookie 大小的限制 ) CSS 优化 将CSS代码放在HTML页面的顶部 避免使用CSS表达式 使用&lt;link&gt;来代替@import 避免使用Filters JavaScript 优化 将JavaScript脚本放在页面的底部 将JavaScript和CSS作为外部文件来引用 缩小JavaScript和CSS 删除重复的脚本 最小化DOM的访问 开发智能的事件处理程序 图像优化 优化图片大小 指定图片大小 使用精灵图 favicon 尽量小, 可缓存 针对移动优化 保持组件大小在 25KB 以下, iPhone 不能缓存 25KB 以上文件 打包组件 作者 : 纪行川 博客 : 行川草庐 声明 : 网站内容可自由转载 , 转载请附上作者信息和详细链接]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6常用语法]]></title>
      <url>%2F2017%2F01%2F04%2FJavaScript%2FES6%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%2F</url>
      <content type="text"><![CDATA[声明 : 此篇为转载内容 , 想详细学习 ES6 语法, 可以去拜读下阮一峰写的 ECMAScript 6 入门 ( 第二版 ) ECMAScript 6（以下简称ES6）是JavaScript语言的下一代标准。因为当前版本的ES6是在2015年发布的，所以又称ECMAScript 2015。 也就是说，ES6就是ES2015。虽然目前并不是所有浏览器都能兼容ES6全部特性，但越来越多的程序员在实际项目当中已经开始使用ES6了。所以就算你现在不打算使用ES6，但为了看懂别人的你也该懂点ES6的语法了…在我们正式讲解ES6语法之前，我们得先了解下Babel。 Babel Babel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。大家可以选择自己习惯的工具来使用使用Babel，具体过程可直接在Babel官网查看： 最常用的ES6特性 : let, const, class, extends, super, arrow functions, template string, destructuring, default, rest arguments 这些是ES6最常用的几个语法，基本上学会它们，我们就可以走遍天下都不怕啦！我会用最通俗易懂的语言和例子来讲解它们，保证一看就懂，一学就会。let, const这两个的用途与var类似，都是用来声明变量的，但在实际运用中他俩都有各自的特殊用途。首先来看下面这个例子： 123456789101112var name ='zach'while(true)&#123; var name ='obama' console.log(name) //obama break&#125;console.log(name) //obama 使用var 两次输出都是obama，这是因为ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。第一种场景就是你现在看到的内层变量覆盖外层变量。而let则实际上为JavaScript新增了块级作用域。用它所声明的变量，只在let命令所在的代码块内有效。 123456789let name ='zach' while(true)&#123; let name ='obama' console.log(name) //obama break&#125; console.log(name) //zach 另外一个var带来的不合理场景就是用来计数的循环变量泄露为全局变量，看下面的例子： 1234567var a =[];for(var i =0; i &lt;10; i++)&#123; a[i]=function()&#123; console.log(i); &#125;;&#125;a[6]();// 10 上面代码中，变量i是var声明的，在全局范围内都有效。所以每一次循环，新的i值都会覆盖旧值，导致最后输出的是最后一轮的i的值。而使用let则不会出现这个问题。 1234567var a =[];for(let i =0; i &lt;10; i++)&#123; a[i]=function()&#123; console.log(i); &#125;;&#125;a[6]();// 6 再来看一个更常见的例子，了解下如果不用ES6，而用闭包如何解决这个问题。 123456var clickBoxs = document.querySelectorAll('.clickBox')for(var i =0; i &lt; clickBoxs.length; i++)&#123; clickBoxs[i].onclick =function()&#123; console.log(i) &#125;&#125; 我们本来希望的是点击不同的clickBox，显示不同的i，但事实是无论我们点击哪个clickBox，输出的都是5。下面我们来看下，如何用闭包搞定它。 12345678910function iteratorFactory(i)&#123; var onclick =function(e)&#123; console.log(i) &#125; return onclick;&#125;var clickBoxs = document.querySelectorAll('.clickBox')for(var i =0; i &lt; clickBoxs.length; i++)&#123; clickBoxs[i].onclick = iteratorFactory(i)&#125; const也用来声明变量，但是声明的是常量。一旦声明，常量的值就不能改变。 当我们尝试去改变用const声明的常量时，浏览器就会报错。const有一个很好的应用场景，就是当我们引用第三方库的时声明的变量，用const来声明可以避免未来不小心重命名而导致出现bug：1const monent =require(&apos;moment&apos;) class, extends, super这三个特性涉及了ES5中最令人头疼的的几个部分：原型、构造函数，继承…你还在为它们复杂难懂的语法而烦恼吗？你还在为指针到底指向哪里而纠结万分吗？有了ES6我们不再烦恼！ ES6提供了更接近传统语言的写法，引入了Class（类）这个概念。新的class写法让对象原型的写法更加清晰、更像面向对象编程的语法，也更加通俗易懂。 123456789101112131415161718192021classAnimal&#123; constructor()&#123; this.type ='animal' &#125; says(say)&#123; console.log(this.type +' says '+ say) &#125;&#125; let animal =newAnimal()animal.says('hello')//animal says hello classCatextendsAnimal&#123; constructor()&#123; super() this.type ='cat' &#125;&#125; let cat =newCat()cat.says('hello')//cat says hello 上面代码首先用class定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。简单地说，constructor内定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实例对象可以共享的。Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。上面定义了一个Cat类，该类通过extends关键字，继承了Animal类的所有属性和方法。 super关键字，它指代父类的实例（即父类的this对象）。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。ES6的继承机制，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。P.S 如果你写react的话，就会发现以上三个东西在最新版React中出现得很多。创建的每个component都是一个继承React.Component的类。详见react文档arrow function这个恐怕是ES6最最常用的一个新特性了，用它来写function比原来的写法要简洁清晰很多: 12function(i)&#123;return i +1;&#125;//ES5(i)=&gt; i +1//ES6 简直是简单的不像话对吧…如果方程比较复杂，则需要用{}把代码包起来：123456function(x, y)&#123; x++; y--; return x + y;&#125;(x, y)=&gt;&#123;x++; y--;return x+y&#125; 除了看上去更简洁以外，arrow function还有一项超级无敌的功能！长期以来，JavaScript语言的this对象一直是一个令人头痛的问题，在对象方法中使用this，必须非常小心。例如：12345678910111213classAnimal&#123; constructor()&#123; this.type ='animal' &#125; says(say)&#123; setTimeout(function()&#123; console.log(this.type +' says '+ say) &#125;,1000) &#125;&#125; var animal =newAnimal() animal.says('hi') //undefined says hi 运行上面的代码会报错，这是因为setTimeout中的this指向的是全局对象。所以为了让它能够正确的运行，传统的解决方法有两种：第一种是将this传给self,再用self来指代this12345says(say)&#123; varself=this; setTimeout(function()&#123; console.log(self.type +' says '+ say) &#125;,1000) 第二种方法是用bind(this),即1234says(say)&#123; setTimeout(function()&#123; console.log(this.type +' says '+ say) &#125;.bind(this),1000) 但现在我们有了箭头函数，就不需要这么麻烦了：123456789101112classAnimal&#123; constructor()&#123; this.type ='animal' &#125; says(say)&#123; setTimeout(()=&gt;&#123; console.log(this.type +' says '+ say) &#125;,1000) &#125;&#125;var animal =newAnimal() animal.says('hi') //animal says hi 当我们使用箭头函数时，函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，它的this是继承外面的，因此内部的this就是外层代码块的this。template string这个东西也是非常有用，当我们要插入大段的html内容到文档中时，传统的写法非常麻烦，所以之前我们通常会引用一些模板工具库，比如mustache等等。大家可以先看下面一段代码：123456$("#result").append( "There are &lt;b&gt;"+ basket.count +"&lt;/b&gt; "+ "items in your basket, "+ "&lt;em&gt;"+ basket.onSale + "&lt;/em&gt; are on sale!"); 我们要用一堆的’+’号来连接文本与变量，而使用ES6的新特性模板字符串“后，我们可以直接这么来写：12345$("#result").append(` There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt; are on sale!`); 用反引号（\）来标识起始，用${}来引用变量，而且所有的空格和缩进都会被保留在输出之中，是不是非常爽？！React Router`从第1.0.3版开始也使用ES6语法了，比如这个例子：1&lt;Linkto=&#123;`/taco/$&#123;taco.name&#125;`&#125;&gt;&#123;taco.name&#125;&lt;/Link&gt; destructuring ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。看下面的例子：1234let cat ='ken'let dog ='lili'let zoo =&#123;cat: cat, dog: dog&#125;console.log(zoo) //Object &#123;cat: "ken", dog: "lili"&#125; 用ES6完全可以像下面这么写：1234let cat ='ken'let dog ='lili'let zoo =&#123;cat, dog&#125;console.log(zoo) //Object &#123;cat: "ken", dog: "lili"&#125; 反过来可以这么写：123let dog =&#123;type:'animal', many:2&#125;let&#123; type, many&#125;= dogconsole.log(type, many) //animal 2 default, restdefault很简单，意思就是默认值。大家可以看下面的例子，调用animal()方法时忘了传参数，传统的做法就是加上这一句type = type || ‘cat’ 来指定默认值。12345function animal(type)&#123; type = type ||'cat' console.log(type)&#125;animal() 如果用ES6我们而已直接这么写：1234function animal(type ='cat')&#123; console.log(type)&#125;animal() 最后一个rest语法也很简单，直接看例子：1234function animals(...types)&#123; console.log(types)&#125;animals('cat','dog','fish')//["cat", "dog", "fish"] 而如果不用ES6的话，我们则得使用ES5的arguments。import export这两个家伙对应的就是es6自己的module功能。我们之前写的Javascript一直都没有模块化的体系，无法将一个庞大的js工程拆分成一个个功能相对独立但相互依赖的小工程，再用一种简单的方法把这些小工程连接在一起。 这有可能导致两个问题： 一方面js代码变得很臃肿，难以维护 另一方面我们常常得很注意每个script标签在html中的位置，因为它们通常有依赖关系，顺序错了可能就会出bug 在es6之前为解决上面提到的问题，我们得利用第三方提供的一些方案，主要有两种CommonJS(服务器端)和AMD（浏览器端，如require.js）。 而现在我们有了es6的module功能，它实现非常简单，可以成为服务器和浏览器通用的模块解决方案。 ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西。上面的设计思想看不懂也没关系，咱先学会怎么用，等以后用多了、熟练了再去研究它背后的设计思想也不迟！好，那我们就上代码… 传统的写法首先我们回顾下require.js的写法。假设我们有两个js文件: index.js和content.js,现在我们想要在index.js中使用content.js返回的结果，我们要怎么做呢？首先定义：1234//content.jsdefine('content.js',function()&#123; return'A cat';&#125;) 然后require：1234//index.jsrequire(['./content.js'],function(animal)&#123; console.log(animal); //A cat&#125;) 那CommonJS是怎么写的呢？12345//index.jsvar animal =require('./content.js')//content.jsmodule.exports ='A cat' ES6的写法12345//index.jsimport animal from'./content' //content.jsexportdefault'A cat' 以上我把三者都列出来了，妈妈再也不用担心我写混淆了…ES6 module的其他高级用法1234567//content.js exportdefault'A cat' exportfunction say()&#123; return'Hello!'&#125; exportconst type ='dog' 上面可以看出，export命令除了输出变量，还可以输出函数，甚至是类（react的模块基本都是输出类）12345//index.js import&#123; say, type &#125;from'./content' let says = say()console.log(`The $&#123;type&#125; says $&#123;says&#125;`) //The dog says Hello 这里输入的时候要注意：大括号里面的变量名，必须与被导入模块（content.js）对外接口的名称相同。如果还希望输入content.js中输出的默认值(default), 可以写在大括号外面。123456//index.js import animal,&#123; say, type &#125;from'./content' let says = say()console.log(`The $&#123;type&#125; says $&#123;says&#125; to $&#123;animal&#125;`) //The dog says Hello to A cat 修改变量名此时我们不喜欢type这个变量名，因为它有可能重名，所以我们需要修改一下它的变量名。在es6中可以用as实现一键换名。123456//index.js import animal,&#123; say, type as animalType &#125;from'./content' let says = say()console.log(`The $&#123;animalType&#125; says $&#123;says&#125; to $&#123;animal&#125;`) //The dog says Hello to A cat 模块的整体加载除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。123456//index.js import animal,*as content from'./content' let says = content.say()console.log(`The $&#123;content.type&#125; says $&#123;says&#125; to $&#123;animal&#125;`) //The dog says Hello to A cat 通常星号*结合as一起使用比较合适。终极秘籍考虑下面的场景：上面的content.js一共输出了三个变量（default, say, type）,假如我们的实际项目当中只需要用到type这一个变量，其余两个我们暂时不需要。我们可以只输入一个变量：1import&#123; type &#125;from'./content' 由于其他两个变量没有被使用，我们希望代码打包的时候也忽略它们，抛弃它们，这样在大项目中可以显著减少文件的体积。 ES6帮我们实现了！ 不过，目前无论是webpack还是browserify都还不支持这一功能… 如果你现在就想实现这一功能的话，可以尝试使用rollup.js 他们把这个功能叫做Tree-shaking，哈哈哈，意思就是打包前让整个文档树抖一抖，把那些并未被依赖或使用的东西统统抖落下去。。。 看看他们官方的解释吧： 总结以上就是ES6最常用的一些语法，可以说这20%的语法，在ES6的日常使用中占了80%…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[事件添加、删除,阻止冒泡和浏览器默认行为的兼容性写法]]></title>
      <url>%2F2016%2F10%2F02%2FJavaScript%2F%E4%BA%8B%E4%BB%B6%E6%B7%BB%E5%8A%A0%E3%80%81%E5%88%A0%E9%99%A4-%E9%98%BB%E6%AD%A2%E5%86%92%E6%B3%A1%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E5%86%99%E6%B3%95%2F</url>
      <content type="text"><![CDATA[添加事件1234567const addEvent = function(obj, type, fn) &#123; if (obj.addEventListener) &#123; obj.addEventListener(type, fn, false) &#125;else if (obj.attachEvent) &#123; obj.attachEvent('on' + type, fn) &#125;&#125; 移除事件1234567const removeEvent = function(obj, type, fn) &#123; if (obj.removeEventListener) &#123; obj.removeEventListener(type, fn, false) &#125;else if (obj.detachEvent) &#123; obj.detachEvent('on' + type, fn) &#125;&#125; 阻止冒泡事件和浏览器默认行为12345678910const stopEvent = function (e) &#123; e = e || window.event if (e.preventDefault) &#123; e.preventDefault() e.stopPropagation() &#125;else&#123; e.returnValue = false e.cancelBubble = true &#125;&#125; 阻止冒泡事件12345678const stopPropagation = function (e) &#123; e = e || window.event if (e.stopPropagation) &#123; e.stopPropagation() &#125;else &#123; e.cancelBubble = true &#125;&#125; 阻止浏览器默认行为12345678const preventDefault = function(e) &#123; e = e || window.event; if(e.preventDefault) &#123; e.preventDefault(); &#125;else&#123; e.returnValue = false; &#125;&#125; 获取事件源12345const getEventTarget = function (e) &#123; e = e || window.event var target = e.srcElement?e.srcElement:e.target return target&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前后端分离的发展过程]]></title>
      <url>%2F2016%2F09%2F23%2Fworks%2F%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E5%8F%91%E5%B1%95%E8%BF%87%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[前后端未分离开发模式的缺点 前端完成页面, 后端翻译成模版, 如果前端界面变动, 需要重新再走一遍流程, 开发效率低 前后端代码强耦合, 维护成本高 前后端分工不明确, 沟通成本高 分离与未分离的比较 交互形式 在前后端分离架构中，后端只需要负责按照约定的数据格式向前端提供可调用的API服务即可.前后端之间通过HTTP请求进行交互，前端获取到数据后，进行页面的装配和渲染. 代码组织方式 半分离 前后端共用一个代码库，但是代码分别存放在两个工程中。后端不关心或很少关心前端元素的输出情况，前端不能独立进行开发和测试，项目中缺乏前后端交互的测试用例 分离 前后端代码库分离，前端代码中有可以进行Mock测试，能支持前端的独立开发和测试.而后端代码中除了功能实现外，还有着详细的测试用例，以保证API的可用性，降低集成风险. 开发模式 前后端未分离的开发流程 提出需求 -&gt; 前端开发 -&gt; 后端翻译成模版 -&gt; 前后端对接 -&gt; 联调遇到问题 -&gt; 前端返工 -&gt; 后端返工 -&gt; 二次集成 -&gt;联调成功 -&gt; 交付 前后端分离后的开发流程 提出需求 -&gt; 约定数据接口 -&gt; 前后端并行开发 -&gt; 前后端联调 -&gt; 前端调整页面 -&gt; 联调成功 -&gt; 交付 在开发模式上, 我们可以看到, 前后端分离不仅仅是工作内容的分离, 更重要的意义是可以并行开发, 简化了工作流程. 前后端分离的几种方案 Nginx + Server 将前端资源部署在Nginx上，后端服务部署在常规的服务器.当浏览器发起访问请求的时候，如果请求的是页面资源，Nginx直接把资源返回到前端；如果请求是调用后端服务，则经过Nginx转发到后端服务器，完成响应后经Nginx返回到浏览器. 缺点: Nginx 只是向浏览器返回页面静态资源，而国内的搜索引擎爬虫只会抓取静态数据，不会解析页面中的js，这使得应用得不到良好的搜索引擎支持. 同时因为 Nginx 不会进行页面的组装渲染，需要服务器把完成渲染工作，这加重了浏览器的渲染负担. Node + Server 这是淘宝所使用的前后端分离模式，在浏览器与后端服务器之间增加一个了Node Server作为中间层，将前端资源部署到 Node Server 中. Node Server 中还包含了一层 Model Proxy，负责与服务端进行通信. 浏览器发出的请求都被Node Server接收，然后通过Model Proxy调用后端服务器提供的服务.Node Server得到后端服务器反馈，接着在Node Server中完成页面的组装渲染，把最终页面返回给浏览器. 缺点: 浏览器所有发出的请求都需要经过Node Server进行中转，然后才能到达后端服务器.在实际的应用中，并不是所有的请求都需要页面渲染，只要在页面上直接调用后端服务器提供的服务即可.所以这个模式必然会对请求性能有所消耗. Nginx + Node + Server 为了能解决方案2中请求性能损失的问题，我们可以考虑在其基础之上增加Nginx.浏览器发起的请求经过Nginx进行分发，URL请求统一分发到Node Server，在Node Server中进行页面组装渲染；API请求则直接发送到后端服务器，完成响应. 作者 : 纪行川 博客 : 行川草庐 声明 : 网站内容可自由转载 , 转载请附上作者信息和详细链接]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动web开发之viewport]]></title>
      <url>%2F2016%2F08%2F07%2Fmobile%2F%E7%A7%BB%E5%8A%A8web%E5%BC%80%E5%8F%91%E4%B9%8Bviewport%2F</url>
      <content type="text"><![CDATA[为了移动多终端适配，苹果提出viewport的概念，并在Safari上推行，目前各厂商均已实现适配 开启viewport浏览器默认不开启viewport,如要开启viewport,需要再head标签中加入以下内容1&lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"&gt; 让viewport的宽度等于设备宽度,不允许设备缩放,防止误触破坏界面效果,默认同时也是最大缩放比限制在1.0 emmet语法支持meta:vp+tab快捷输出 viewport属性在苹果的规范中，meta viewport 有6个属性，如下： width 设置layout viewport的宽度，为一个正整数，或设置字符串”width-device”,让其等于设备宽度,实现自适应 initial-scale 设置页面的初始缩放值，为一个数字，可以带小数 minimum-scale 允许用户的最小缩放值，为一个数字，可以带小数 maximum-scale 允许用户的最大缩放值，为一个数字，可以带小数 height 设置layout viewport的高度，很少使用 user-scalable 是否允许用户进行缩放,no代表不允许,yes代表允许 这些属性可以同时使用，也可以单独使用或混合使用，多个属性同时使用时用逗号隔开就行了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[清除浮动的几种方法]]></title>
      <url>%2F2016%2F08%2F04%2FHTML%26CSS%2F%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[给父元素设置固定高度 12345678910111213&lt;style type="text/css"&gt; .div1&#123;background:#000080;border:1px solid red;/*解决代码*/height:200px;&#125; .div2&#123;background:#800080;border:1px solid red;height:100px;margin-top:10px&#125; .left&#123;float:left;width:20%;height:200px;background:#DDD&#125; .right&#123;float:right;width:30%;height:80px;background:#DDD&#125; &lt;/style&gt; &lt;div class="div1"&gt; &lt;div class="left"&gt;Left&lt;/div&gt; &lt;div class="right"&gt;Right&lt;/div&gt; &lt;/div&gt; &lt;div class="div2"&gt; div2 &lt;/div&gt; 结尾处加空标签 clear-both 123456789101112131415161718&lt;style type="text/css"&gt; .div1&#123;background:#000080;border:1px solid red&#125; .div2&#123;background:#800080;border:1px solid red;height:100px;margin-top:10px&#125; .left&#123;float:left;width:20%;height:200px;background:#DDD&#125; .right&#123;float:right;width:30%;height:80px;background:#DDD&#125; /*清除浮动代码*/ .clearfloat&#123;clear:both&#125; &lt;/style&gt; &lt;div class="div1"&gt; &lt;div class="left"&gt;Left&lt;/div&gt; &lt;div class="right"&gt;Right&lt;/div&gt;&lt;div class="clearfloat"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="div2"&gt; div2 &lt;/div&gt; 父级使用 clearfix:after 123456789101112131415161718&lt;style type="text/css"&gt; .div1&#123;background:#000080;border:1px solid red;&#125; .div2&#123;background:#800080;border:1px solid red;height:100px;margin-top:10px&#125; .left&#123;float:left;width:20%;height:200px;background:#DDD&#125; .right&#123;float:right;width:30%;height:80px;background:#DDD&#125; /*清除浮动代码*/ .clearfloat:after&#123;display:block;clear:both;content:"";visibility:hidden;height:0&#125; .clearfloat&#123;zoom:1&#125; &lt;/style&gt; &lt;div class="div1 clearfloat"&gt; &lt;div class="left"&gt;Left&lt;/div&gt; &lt;div class="right"&gt;Right&lt;/div&gt; &lt;/div&gt;&lt;div class="div2"&gt; div2 &lt;/div&gt; 父级div定义overflow:hidden 1234567891011121314&lt;style type="text/css"&gt; .div1&#123;background:#000080;border:1px solid red;/*解决代码*/width:98%;overflow:hidden&#125; .div2&#123;background:#800080;border:1px solid red;height:100px;margin-top:10px;width:98%&#125; .left&#123;float:left;width:20%;height:200px;background:#DDD&#125; .right&#123;float:right;width:30%;height:80px;background:#DDD&#125; &lt;/style&gt; &lt;div class="div1"&gt; &lt;div class="left"&gt;Left&lt;/div&gt; &lt;div class="right"&gt;Right&lt;/div&gt;&lt;/div&gt;&lt;div class="div2"&gt; div2 &lt;/div&gt; 淘宝用的 before, after 伪元素, display: table 123456789101112.clearfix:before, .clearfix:after &#123; content: ''; display: table;&#125;.clearfix:after &#123; clear:both;&#125;.clearfix &#123; *zoom: 1; /*IE/7/6*/&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS模拟堆栈和队列操作]]></title>
      <url>%2F2016%2F08%2F03%2FJavaScript%2Fjs%E6%A8%A1%E6%8B%9F%E5%A0%86%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[在面向对象的设计模式中, 一般提供了队列(queue)和堆栈(stack)的方法, 而对于 JS , 可以用数组来模拟其操作流程: 堆栈堆栈操作只允许在一端添加、删除操作, 这端叫做栈顶, 另一端叫做栈底, 秉承后进先出的原则. 1234567891011const arr = []for (let i = 0; i &lt; 5; i++) &#123; const temp = i + 1 arr.push(temp) console.log(`$&#123;temp&#125;, 进栈了`)&#125;console.log('\n')const len = arr.lengthfor (let i = 0; i &lt; len; i++) &#123; console.log(arr.pop() + `, 出栈了`)&#125; 队列队列操作允许前端插入, 后端取出, 秉承先进先出的原则. 1234567891011const arr = []for (let i = 0; i &lt; 5; i++) &#123; const temp = i + 1 arr.unshift(temp) console.log(`$&#123;temp&#125;, 插入队列`)&#125;console.log('\n')const len = arr.lengthfor (let i = 0; i &lt; len; i++) &#123; console.log(arr.pop() + `, 出来了`)&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Apple ID更换主显邮箱后不能注销iCloud账号]]></title>
      <url>%2F2016%2F07%2F02%2Fexperiences%2FApple%20ID%E6%9B%B4%E6%8D%A2%E4%B8%BB%E6%98%BE%E9%82%AE%E7%AE%B1%E5%90%8E%E4%B8%8D%E8%83%BD%E6%B3%A8%E9%94%80iCloud%E8%B4%A6%E5%8F%B7%2F</url>
      <content type="text"><![CDATA[多年前入手了一台ipad mini2,主要用来看电影、煲剧. Apple id绑定的是163邮箱,因为历史原因,邮箱绑定的手机号无法更换了,所以换了一个邮箱. 结果悲剧的情况来了,ipad上iCloud账号还是显示原来的163邮箱,输入任何密码都提示错误,无法注销! 联系apple客服,和我说了半天,说他也没遇到这个情况,让我准备发票、保修卡等购物凭证再联系他们. 买了好几年了,早不知道放到哪里去了,卒~ 尝试了一些方法,终于解决了这个问题. 在这里说明一下,防止有其他人掉这个坑里爬不出来. 如果你有发票等购物凭证,而且原邮箱无法接收邮件,联系苹果客服处理吧,虽然繁琐,不过是可以解决的 如果你没有发票,原邮箱可以接收邮件,把Apple ID的主显邮箱改回原邮箱,注销掉所有设备上登录的账号,再更改邮箱 如果你什么都没有,自求多福吧 (。・_・)/ 我用的第二种解决方案,这里我要吐槽一下网易邮箱,手机号忘记更换,申诉了几年一直失败,苹果发来的邮件163邮箱给你自动加密,必须要手机验证码才能查看,所以之前一直没法改,最近突然发现不加密了,才解决这个问题. 这里提醒各位,常用的邮箱,或者你打算长期持有的邮箱地址,绑定手机号一直要实时更新. 特别网易邮箱,很多用户手机号忘记更换,几年都申诉不回来.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Harmony(ES3.1改版)学习总结]]></title>
      <url>%2F2016%2F06%2F10%2FJavaScript%2FHarmony(ES3.1%E6%94%B9%E7%89%88)%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[变量声明 let 只在当前块级作用域中有效 let语句:只能在后续代码块中使用的变量 12345var num = 5;let (num=10, multiplier=2)&#123;alert(num * multiplier); //20&#125;alert(num); //5 let 表达式: 123var result = let(num=10, multiplier=2) num * multiplier;alert(result); //20//这里的 let 表达式使用两个变量计算后得到一个值，保存在变量 result中。执行表达式之后， num和 multiplier 变量就不存在了。 const 常量,声明后不能再更改其中的值 函数剩余参数与分布参数 剩余参数 ( rest arguments ) 剩余参数的语法形式是三个点后跟一个标识符...nums 123456789function sum(num1, num2, ...nums)&#123;var result = num1 + num2;for (let i=0, len=nums.length; i &lt; len; i++)&#123;result += nums[i];&#125;return result;&#125;var result = sum(1, 2, 3, 4, 5, 6);console.log(result) //21 分布参数（spread arguments） 通过分布参数，可以向函数中传入一个数组，然后数组中的元素会映射到函数的每个参数上 分布参数的语法形式与剩余参数的语法相同，就是在值的前面加三个点。唯一的区别是分布参数在调用函数的时候使用，而剩余参数在定义函数的时候使用 1var result = sum(...[1, 2, 3, 4, 5, 6]); 1var result = sum.apply(null, [1, 2, 3, 4, 5, 6]); 参数默认值要为参数指定默认值，可以在参数名后面直接加上等于号和默认值12345function sum(num1, num2=0)&#123;return num1 + num2;&#125;var result1 = sum(5);var result2 = sum(5, 5); 生成器对 Harmony 而言，要创建生成器，可以让函数通过 yield 操作符返回某个特殊的值。对于使用 yield操作符返回值的函数，调用它时就会创建并返回一个新的 Generator 实例。然后，在这个实例上调用 next() 方法就能取得生成器的第一个值。此时，执行的是原来的函数，但执行流到 yield 语句就会停止，只返回特定的值。从这个角度看， yield 与 return 很相似。如果再次调用 next() 方法，原来函数中位于 yield 语句后的代码会继续执行，直到再次遇见 yield 语句时停止执行，此时再返回一个新值 123456789101112131415function myNumbers()&#123;for (var i=0; i &lt; 10; i++)&#123;yield i * 2;&#125;&#125;var generator = myNumbers();try &#123;while(true)&#123;document.write(generator.next() + "&lt;br /&gt;");&#125;&#125; catch(ex)&#123;//有意没有写代码&#125; finally &#123;generator.close();&#125; 数组及其他结构迭代器要为对象创建迭代器，可以调用 Iterator 构造函数，传入想要迭代其值的对象。要取得对象中的下一个值，可以调用迭代器的 next() 方法12345678910111213var person = &#123;name: &quot;Nicholas&quot;,age: 29&#125;;var iterator = new Iterator(person);try &#123; while(true)&#123; let value = iterator.next(); document.write(value.join(&quot;:&quot;) + &quot;&lt;br&gt;&quot;);&#125;&#125; catch(ex)&#123;//有意没有写代码&#125; 数组领悟JavaScript 中数组领悟的基本形式如下：1array = [ value for each (variable in values) condition ]; 12345678910//原始数组var numbers = [0,1,2,3,4,5,6,7,8,9,10];//把所有元素复制到新数组var duplicate = [i for each (i in numbers)];//只把偶数复制到新数组var evens = [i for each (i in numbers) if (i % 2 == 0)];//把每个数乘以 2 后的结果放到新数组中var doubled = [i*2 for each (i in numbers)];//把每个奇数乘以 3 后的结果放到新数组中var tripledOdds = [i*3 for each (i in numbers) if (i % 2 &gt; 0)]; 待续发现很多属性和方法已经不可用了,暂时先看到这里]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[setTimeout的秘密]]></title>
      <url>%2F2016%2F06%2F03%2FJavaScript%2FsetTimeout%E7%9A%84%E7%A7%98%E5%AF%86%2F</url>
      <content type="text"><![CDATA[计时器setTimeout是我们经常会用到的，它用于在指定的毫秒数后调用函数或计算表达式。 语法： setTimeout(code, millisec, args); 注意：如果code为字符串，相当于执行eval()方法来执行code。 当然，这一篇文章并不仅仅告诉你怎么用setTimeout，而且理解其是如何执行的。 1、setTimeout原理先来看一段代码： 1234567891011varstart = newDate(); varend = 0; setTimeout(function()&#123; console.log(newDate() - start); &#125;, 500); while(newDate() - start &lt;= 1000)&#123;&#125; 在上面的代码中，定义了一个setTimeout定时器，延时时间是500毫秒。 你是不是觉得打印结果是： 500 可事实却是出乎你的意料，打印结果是这样的（也许你打印出来会不一样，但肯定会大于1000毫秒）： 这是为毛呢？ 究其原因，这是因为 JavaScript是单线程执行的。也就是说，在任何时间点，有且只有一个线程在运行JavaScript程序，无法同一时候运行多段代码。 再来看看浏览器下的JavaScript。 浏览器的内核是多线程的，它们在内核控制下相互配合以保持同步，一个浏览器至少实现三个常驻线程：JavaScript引擎线程，GUI渲染线程，浏览器事件触发线程。 * JavaScript引擎是基于事件驱动单线程执行的，JavaScript引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个JavaScript线程在运行JavaScript程序。 * GUI渲染线程负责渲染浏览器界面，当界面需要重绘（Repaint）或由于某种操作引发回流(Reflow)时，该线程就会执行。但需要注意，GUI渲染线程与JavaScript引擎是互斥的，当JavaScript引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JavaScript引擎空闲时立即被执行。 * 事件触发线程，当一个事件被触发时，该线程会把事件添加到待处理队列的队尾，等待JavaScript引擎的处理。这些事件可来自JavaScript引擎当前执行的代码块如setTimeout、也可来自浏览器内核的其他线程如鼠标点击、Ajax异步请求等，但由于JavaScript的单线程关系，所有这些事件都得排队等待JavaScript引擎处理（当线程中没有执行任何同步代码的前提下才会执行异步代码）。 到这里，我们再来回顾一下最初的例子： 1234567891011varstart = newDate(); varend = 0; setTimeout(function()&#123; console.log(newDate() - start); &#125;, 500); while(newDate() - start &lt;= 1000)&#123;&#125; 虽然setTimeout的延时时间是500毫秒，可是由于while循环的存在，只有当间隔时间大于1000毫秒时，才会跳出while循环，也就是说，在1000毫秒之前，while循环都在占据着JavaScript线程。也就是说，只有等待跳出while后，线程才会空闲下来，才会去执行之前定义的setTimeout。 最后 ，我们可以总结出，setTimeout只能保证在指定的时间后将任务(需要执行的函数)插入任务队列中等候，但是不保证这个任务在什么时候执行。一旦执行javascript的线程空闲出来，自行从队列中取出任务然后执行它。 因为javascript线程并没有因为什么耗时操作而阻塞，所以可以很快地取出排队队列中的任务然后执行它，也是这种队列机制，给我们制造一个异步执行的假象。 2、setTimeout的好搭档“0”也许你见过下面这一段代码： 12345setTimeout(function()&#123; // statement &#125;,0); 上面的代码表示立即执行。 本意是立刻执行调用函数，但事实上，上面的代码并不是立即执行的，这是因为setTimeout有一个最小执行时间，当指定的时间小于该时间时，浏览器会用最小允许的时间作为setTimeout的时间间隔，也就是说即使我们把setTimeout的延迟时间设置为0，被调用的程序也没有马上启动。 不同的浏览器实际情况不同，IE8和更早的IE的时间精确度是15.6ms。不过，随着HTML5的出现，在高级版本的浏览器（Chrome、ie9+等），定义的最小时间间隔是不得低于4毫秒，如果低于这个值，就会自动增加，并且在2010年及之后发布的浏览器中采取一致。 所以说，当我们写为 setTimeout(fn,0) 的时候，实际是实现插队操作，要求浏览器“尽可能快”的进行回调，但是实际能多快就完全取决于浏览器了。 那setTimeout(fn, 0)有什么用处呢？其实用处就在于我们可以改变任务的执行顺序！因为浏览器会在执行完当前任务队列中的任务，再执行setTimeout队列中积累的的任务。 通过设置任务在延迟到0s后执行，就能改变任务执行的先后顺序，延迟该任务发生，使之异步执行。 来看一个网上很流行的例子： 12345678document.querySelector('#one input').onkeydown = function()&#123; document.querySelector('#one span').innerHTML = this.value; &#125;; document.querySelector('#second input').onkeydown = function()&#123; setTimeout(function()&#123; document.querySelector('#second span').innerHTML = document.querySelector('#second input').value; &#125;,0);&#125;; 当你往两个表单输入内容时，你会发现未使用setTimeout函数的只会获取到输入前的内容，而使用setTimeout函数的则会获取到输入的内容。 这是为什么呢？ 因为当按下按键的时候，JavaScript 引擎需要执行 keydown 的事件处理程序，然后更新文本框的 value 值，这两个任务也需要按顺序来，事件处理程序执行时，更新 value值（是在keypress后）的任务则进入队列等待，所以我们在 keydown 的事件处理程序里是无法得到更新后的value的，而利用 setTimeout(fn, 0)，我们把取 value 的操作放入队列，放在更新 value 值以后，这样便可获取出文本框的值。 未使用setTimeout函数，执行顺序是：onkeydown =&gt; onkeypress =&gt; onkeyup 使用setTimeout函数，执行顺序是：onkeydown =&gt; onkeypress =&gt; function =&gt; onkeyup 虽然我们可以使用keyup来替代keydown，不过有一些问题，那就是长按时，keyup并不会触发。 长按时，keydown、keypress、keyup的调用顺序： keydown keypress keydown keypress … keyup 也就是说keyup只会触发一次，所以你无法用keyup来实时获取值。 我们还可以用setImmediate()来替代setTimeout(fn,0)： if(!window.setImmediate){ window.setImmediate = function(func,args){ returnwindow.setTimeout(func,0,args); }; window.clearImmediate = window.clearTimeout;} setImmediate()方法用来把一些需要长时间运行的操作放在一个回调函数里，在浏览器完成后面的其他语句后，就立刻执行这个回调函数，必选的第一个参数func，表示将要执行的回调函数，它并不需要时间参数。 注意：目前只有IE10支持此方法，当然，在Nodejs中也可以调用此方法。 3、setTimeout的一些秘密3.1 setTimeout中回调函数的this由于setTimeout() 方法是浏览器 window 对象提供的，因此第一个参数函数中的this其实是指向window对象，这跟变量的作用域有关。 看个例子： 12345678910vara = 1; varobj = &#123; a: 2, test: function()&#123; setTimeout(function()&#123; console.log(this.a); &#125;,0); &#125; &#125;; obj.test(); // 1 不过我们可以通过使用bind()方法来改变setTimeout回调函数里的this 12345678910vara = 1; varobj = &#123; a: 2, test: function()&#123; setTimeout(function()&#123; console.log(this.a); &#125;.bind(this),0); &#125; &#125;; obj.test(); // 2 3.2 setTimeout不止两个参数我们都知道，setTimeout的第一个参数是要执行的回调函数，第二个参数是延迟时间（如果省略，会由浏览器自动设置。在IE，FireFox中，第一次配可能给个很大的数字，100ms上下，往后会缩小到最小时间间隔，Safari，chrome，opera则多为10ms上下。） 其实，setTimeout可以传入第三个参数、第四个参数….，它们表示神马呢？其实是用来表示第一个参数（回调函数）传入的参数。 1234setTimeout(function(a,b)&#123; console.log(a); // 3 console.log(b); // 4&#125;,0,3,4);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解决谷歌账户注册手机号无法重用的问题]]></title>
      <url>%2F2016%2F05%2F04%2Fexperiences%2F%E8%A7%A3%E5%86%B3%E8%B0%B7%E6%AD%8C%E8%B4%A6%E6%88%B7%E6%B3%A8%E5%86%8C%E6%89%8B%E6%9C%BA%E5%8F%B7%E6%97%A0%E6%B3%95%E9%87%8D%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[昨天准备新注册个谷歌账户做公事用途,提示我的手机号已注册过手机服务. 我用的是新手机号,确认自己没用它注册过谷歌账户,但以前手机账户持有人就说不定了. 翻阅无数帖子,终于发现了一个解决办法. 在Android、IOS手机端下载QQ邮箱或者网易邮箱大师等第三方邮箱管理App, 安装完邮箱App后,添加Gmail账户,会自动跳转到Gmail登录界面, 点击登录界面的”新建账户”按钮,填写信息即可成功注册.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[正则表达式匹配表]]></title>
      <url>%2F2016%2F05%2F01%2FJavaScript%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%E8%A1%A8%2F</url>
      <content type="text"><![CDATA[以下是常用正则表达式概要, 留作查询之用 常用的正则表达式字符 字符 含义 ^ 匹配开头 $ 匹配结尾 * 元字符出现0或多次 + 元字符出现1或多次 ? 元字符出现0或1次 {n,m} 匹配n到m次 \b 单词边界 \d 匹配一个数字 \D 匹配一个非数字 \s 匹配一个空白字符 \S 匹配一个非空白字符 \w 匹配一个非特殊字符, 包括_ \W 匹配一个特殊字符]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[推荐一个可以下载Chrome插件的网站]]></title>
      <url>%2F2016%2F05%2F01%2Fcomputer%2F%E6%8E%A8%E8%8D%90%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E4%B8%8B%E8%BD%BDChrome%E6%8F%92%E4%BB%B6%E7%9A%84%E7%BD%91%E7%AB%99%2F</url>
      <content type="text"><![CDATA[当我们在谷歌商店安装过拓展之后, crx 包会被自动删掉,有时, 我们需要提供 crx 给不会使用科学上网技术, 或是网速不稳定的朋友,那么我们需要使用一个第三方提供的下载服务,今天推荐的这个就是我目前在使用的, 使用简单方便. 网址http://chrome-extension-downloader.com/ 使用方法当我们在在谷歌商店打开一个拓展应用的介绍页面时, 我们的地址栏是如下格式的:https://chrome.google.com/webstore/detail/google-keep-chrome-extens/lpcaedmchfhocbbapmcbpinfpgnhiddi 打开网站 将 detail/ 后面的字符串 google-keep-chrome-extens/lpcaedmchfhocbbapmcbpinfpgnhiddi 粘贴到文本框 点击 Download extension 即可自动下载 将下载到的 crx 文件拖到 Chrome 内核浏览器中 安装完毕]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript之词法作用域和动态作用域]]></title>
      <url>%2F2016%2F04%2F30%2FJavaScript%2FJavaScript%E4%B9%8B%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
      <content type="text"><![CDATA[作用域作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。 ECMAScript6之前只有全局作用域和函数作用域。 JavaScript采用词法作用域(lexical scoping)，也就是静态作用域。 静态作用域与动态作用域因为采用词法作用域，函数的作用域在函数定义的时候就决定了。 与词法作用域相对的是动态作用域，函数的作用域在函数调用的时候才决定。 让我们认真看个例子就能明白之间的区别： 12345678910111213var value = 1;function foo() &#123; console.log(value);&#125;function bar() &#123; var value = 2; foo();&#125;bar(); 当采用静态作用域时，执行foo函数，先从foo函数内部查找是否有局部变量value，如果没有，就根据书写的位置，查找上面一层的代码，在这里是全局作用域，也就是value等于1，所以最后会打印1 当采用动态作用域时，执行foo函数，依然是从foo函数内部查找是否有局部变量value。如果没有，就从调用函数的作用域，也就是bar函数内部查找value变量，所以最后会打印2 动态作用域也许你会好奇什么语言是动态作用域？ bash就是动态作用域，不信的话，把下面的脚本存成例如scope.bash，然后进入相应的目录，用命令行执行 bash ./scope.bash，看看打印的值是多少 123456789value=1function foo () &#123; echo $value;&#125;function bar () &#123; local value=2; foo; &#125;bar 思考题最后，让我们看一个《JavaScript权威指南》中的例子： 123456789var scope = "global scope";function checkscope()&#123; var scope = "local scope"; function f()&#123; return scope; &#125; return f();&#125;checkscope(); 123456789var scope = "global scope";function checkscope()&#123; var scope = "local scope"; function f()&#123; return scope; &#125; return f;&#125;checkscope()(); 猜猜两段代码各自的执行结果是多少？ 这里直接告诉大家结果，两段代码都会打印’local scope’。 引用权威指南的回答就是： JavaScript函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript之闭包]]></title>
      <url>%2F2016%2F04%2F29%2FJavaScript%2FJavaScript%E4%B9%8B%E9%97%AD%E5%8C%85%2F</url>
      <content type="text"><![CDATA[什么是闭包MDN 对闭包的定义为：闭包是指形成能够访问自由变量的函数 什么是自由变量？自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。 由此，我们可以看出闭包共有两部分组成： 有一个函数 + 这个函数能够访问自由变量 例子： 12345678var a = 1;function foo() &#123; console.log(a);&#125;foo(); foo 函数可以访问变量a，但是 a 既不是 foo 函数的局部变量，也不是foo函数的参数，所以a就是自由变量。 那么，函数 foo + foo 函数访问的自由变量 a 不就是构成了一个闭包了吗 在《JavaScript权威指南》中就讲到：从技术的角度讲，所有的JavaScript函数都是闭包 别着急，这是理论上的闭包，其实还有一个实践角度上的闭包，让我们看看汤姆大叔翻译的关于闭包的文章中的定义： ECMAScript中，闭包指的是： 从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。 从实践角度：以下函数才算是闭包： 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回） 在代码中引用了自由变量 闭包在实践中的应用123456789101112var scope = "global scope";function checkscope()&#123; var scope = "local scope"; function f()&#123; return scope; &#125; return f;&#125;var foo = checkscope();foo(); 首先让我们回忆一下执行上下文栈的变化情况，这个在《JavaScript深入之执行上下文》中有非常详细的分析。 进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈 全局执行上下文初始化 执行checkscope函数，创建checkscope函数执行上下文，checkscope执行上下文被压入执行上下文栈 checkscope执行上下文初始化，创建变量对象、作用域链、this等 checkscope函数执行完毕，checkscope执行上下文从执行上下文栈中弹出 执行f函数，创建f函数执行上下文，f执行上下文被压入执行上下文栈 f执行上下文初始化，创建变量对象、作用域链、this等 f函数执行完毕，f函数上下文从执行上下文栈中弹出 了解到这个过程，我们应该思考一个问题，那就是： 当f函数执行的时候，checkscope函数上下文已经被销毁了啊(即从执行上下文栈中被弹出)，怎么还会读取到checkscope作用域下的scope值呢？ 以上的代码，要是转换成PHP，就会报错，因为在PHP中，f函数只能读取到自己作用域和全局作用域里的值，所以读不到checkscope下的scope值。(这段我问的PHP同事……) 然而JavaScript却是可以的！ 当我们了解了具体的执行过程后，我们知道f执行上下文维护了一个作用域链： 123fContext = &#123; Scope: [AO, checkscopeContext.AO, globalContext.VO],&#125; 对的，就是因为这个作用域链，f函数依然可以读取到checkscopeContext.AO的值，说明即使checkscopeContext被销毁了，但是checkscopeContext.AO依然活在内存中，f函数依然可以通过f函数的作用域链找到它。而为什么checkscopeContext.AO没有被销毁，正是因为f函数引用了checkscopeContext.AO中的值，又正是因为JS实现了在子上下文引用父上下文的变量的时候，不会销毁这些变量的效果实现了闭包这个概念！ 虽然有点绕，但是一定要多读几遍。 所以，最后在让我们再看一遍实践角度上闭包的定义： 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回） 在代码中引用了自由变量 闭包题1234567891011var data = [];for (var i = 0; i &lt; 3; i++) &#123; data[i] = function () &#123; console.log(i); &#125;;&#125;data[0]();data[1]();data[2](); 答案是都是3，让我们分析一下原因： 当执行到data[0]函数之前，此时全局上下文的VO为： 123456globalContext = &#123; VO: &#123; data: [...], i: 3 &#125;&#125; 当执行data[0]函数的时候，data[0]函数的作用域链为： 123data[0]Context = &#123; Scope: [AO, globalContext.VO]&#125; data[0]Context的AO并没有i值，所以会从globalContext.VO中查找，i为3，所以打印的结果就是3。 data[1]和data[2]是一样的道理。 所以让我们改成闭包看看： 12345678910111213var data = [];for (var i = 0; i &lt; 3; i++) &#123; data[i] = (function (i) &#123; return function()&#123; console.log(i); &#125; &#125;)(i);&#125;data[0]();data[1]();data[2](); 当执行到data[0]函数之前，此时全局上下文的VO为： 123456globalContext = &#123; VO: &#123; data: [...], i: 3 &#125;&#125; 跟没改之前一模一样。 当执行data[0]函数的时候，data[0]函数的作用域链发生了改变： 123data[0]Context = &#123; Scope: [AO, 匿名函数Context.AO globalContext.VO]&#125; 匿名函数执行上下文的AO为： 123456789匿名函数Context = &#123; AO: &#123; arguments: &#123; 0: 1, length: 1 &#125;, i: 0 &#125;&#125; data[0]Context的AO并没有i值，所以会沿着作用域链从匿名函数Context.AO中查找，这时候就会找i为0，找到了就不会往globalContext.VO中查找了，即使globalContext.VO也有i的值(值为3)，所以打印的结果就是0。 data[1]和data[2]是一样的道理。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[bower基本使用]]></title>
      <url>%2F2016%2F04%2F29%2Ftools%2Fbower%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[bower是什么?bower是基于nodejs的静态资源管理工具,由twitter公司开发、维护,使用它可以方便的安装、更新、卸载前端类库,同时解决类库之前的依赖关系. 依赖环境bower依赖于nodejs和git,bower是通过内置的映射表从GitHub上下载类库到本地 安装打开Window命令条窗口,输入以下命令,完成全局安装,-g是全局(global)安装的意思 1npm install -g bower 显示版本号则安装成功 1bower -v 输入上面的指令查看bower当前版本号,我的是”1.8.0”. 映射表查询如果我们想下载jquery-cookie,但不知道bower内置的映射表对应的名称,可以通过以下git指令查询 1$bower search jquery-cookie git窗口会显示以下信息,这就是bower内部设置的映射关系 12345678910Search results: jquery.cookie https://github.com/carhartl/jquery-cookie.git jquery-cookie https://github.com/carhartl/jquery-cookie.git hg-jquery-cookie https://github.com/hackergaucho/hg-jquery-cookie.git jquery-cookie-consent https://github.com/smichaelsen/jquery-cookie-consent.git jquery-cookie-banner https://github.com/alberon/jquery-cookie-banner.git jquery-cookie-alerter https://github.com/siliconsalad/jquery-cookie-alerter.git jaaulde-jquery-cookies https://github.com/JAAulde/jquery-cookies.git jquery-cookie-disclaimer https://github.com/Gix075/cookieDisclaimer.git 类库本地安装知道了映射关系,我们就可以安装类库了 1$ bower install jquery-cookie 在打开git的路径下,自动创建bower_components文件夹,下载jquery-cookie和它依赖的库jquery 类库卸载通过uninstall命令卸载 1$ bower uninstall jquery-cookie 查询类库历史版本1$ bower info jquery git窗口会显示类库详细的历史版本号,默认安装是最新版本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&#123; name: &apos;jquery&apos;, main: &apos;dist/jquery.js&apos;, license: &apos;MIT&apos;, ignore: [ &apos;package.json&apos; ], keywords: [ &apos;jquery&apos;, &apos;javascript&apos;, &apos;browser&apos;, &apos;library&apos; ], homepage: &apos;https://github.com/jquery/jquery-dist&apos;, version: &apos;3.2.1&apos;&#125;Available versions: - 3.2.1 - 3.2.0 - 3.1.1 - 3.1.0 - 3.0.0 - 2.2.4 - 2.2.3 - 2.2.2 - 2.2.1 - 2.2.0 - 2.1.4 - 2.1.3 - 2.1.2 - 2.1.1 - 2.1.0 - 2.0.3 - 2.0.2 - 2.0.1 - 2.0.0 - 1.12.4 - 1.12.3 - 1.12.2 - 1.12.1 - 1.12.0 - 1.11.3 - 1.11.2 - 1.11.1 - 1.11.0 - 1.10.2 - 1.10.1 - 1.10.0 - 1.9.1 - 1.9.0 - 1.8.3 - 1.8.2 - 1.8.1 - 1.8.0 - 1.7.2 - 1.7.1 - 1.7.0 - 1.6.4 - 1.6.3 - 1.6.2 - 1.6.1 - 1.6.0 - 1.5.2 - 1.5.1 - 1.5.0 - 1.4.4 - 1.4.3 - 1.4.2 - 1.4.1 - 1.4.0 - 1.3.2 - 1.3.1 - 1.3.0 - 1.2.6 - 1.2.5 - 1.2.4 - 1.2.3 - 1.2.2 - 1.2.1 - 1.1.4 - 1.1.3 - 1.1.2 - 1.1.1 - 1.0.4 - 1.0.3 - 1.0.2 - 1.0.1 我们也可以安装指定版本的类库 1$ bower install jquery#1.1.2 小结有了bower后,我们不用费心去找各种版本的类库了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IE浏览器兼容性问题]]></title>
      <url>%2F2016%2F04%2F25%2Fworks%2FIE%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[媒体查询 ( Media Query ) IE8 无法识别 Media Query , 推荐用 Respond.js 解决 HMTL5 新标签 nav, footer 等新标签, 推荐用 html5shiv.js 解决 max-width IE8中经常遇到的问题就是 max-width，网页中图片的尺寸可能比较宽，我会给它设置 max-width: 100%来限制其宽度最大为父容器的宽度，但是有时候却不奏效，慢慢摸索才得知IE解析max-width所遵循的规则：严格要求直接父元素的宽度是固定的, 实验发现 Chrome 所遵守的规则比IE松一些. （1）td中的max-width 如果针对td中的img元素设置max-width: 100%，在IE和Firefox你会发现不奏效，而在Chrome中却是可以的。经查询发现需要给table设置table-layout: fixed，对此属性的具体解释见W3School。 （2）嵌套标签中的max-width 如下的HTML结构：12345&lt;div class="work-item"&gt; &lt;a href="#" class="work-link"&gt; &lt;img src="sample.jpg" class="work-image img-responsive"&gt; &lt;/a&gt;&lt;/div&gt; 最外层元素.work-item设置了固定宽度，但是对img设置max-width为100%却无效，后来才发现需要再对a标签设置width: 100%，这样才能使最内层的img标签充满整个div。 嵌套inline-block下padding元素重叠 HTML代码：12345&lt;ul&gt; &lt;li&gt;&lt;a&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;3&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; CSS代码：1234567ul li&#123; display: inline-block;&#125;ul li a&#123; display: inline-block; padding: 10px 15px;&#125; 按理来说a标签之间的距离应该是30px，但在IE8中出现了重叠，只有15px。这里和这里也提到了同样的问题。我的解决方法是使用float: left替代display: inline-block实现水平布局。 placeholder IE8下不支持HTML5属性placeholder，不过为解决此问题的js插件挺多的，比如：jquery-placeholder。 last-child first-child是CSS2的内容，但是last-child就不是了，所以IE8不买账。推荐的做法不是使用last-child，而是给最后一个元素设置一个.last的class，然后对此进行样式设置，这样就全部兼容了。 background-size: cover 如果你想使用background-size: cover设置全屏背景，很遗憾IE8办不到…但可以使用IE独有的AlphaImageLoader滤镜来实现，添加一条如下的CSS样式： filter: progid:DXImageTransform.Microsoft.AlphaImageLoader(enabled=Enabled, sizingMethod=Size , src=URL)将sizingMethod设置为scale就OK了。 还没完，如果你在此背景之上放置了链接，那这个链接是无法点击的。一般情况下的解决办法是为链接或按钮添加position:relative使其相对浮动。 console.log() 打断 IE8 Ajax请求语句 慎用 块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大 在float的标签样式控制中加入 display:inline;将其转化为行内属性 设置较小高度标签（一般小于10px），在IE6，IE7，遨游中高度超出自己设置高度 给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。 行内属性标签，设置display:block后采用float布局，又有横行的margin的情况，IE6间距bug 在display:block;后面加入display:inline;display:table; 图片默认有间距 使用float属性为img布局 标签最低高度设置min-height不兼容 如果我们要设置一个标签的最小高度200px，需要进行的设置为：{min-height:200px; height:auto !important; height:200px; overflow:visible;} 透明度的兼容CSS设置 ie中用的是filter:alpha(opacity=0);这个属性来设置div或者是块级元素的透明度，而在firefox中，一般就是直接使用opacity:0,对于兼容的，一般的做法就是在书写css样式的将2个都写上就行]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git安装及使用]]></title>
      <url>%2F2016%2F03%2F06%2Ftools%2FGit%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[Git控制流程图 Git安装 以下说明均是基于Window环境(本人电脑环境) msysgit是windows版的git，从https://git-for-windows.github.io下载，然后按默认选项安装即可。 在开始菜单里找到“git”-&gt;“git bash”，蹦出一个类似命令行窗口的东西，说明git安装成功 安装完成后进行以下设置: 12$ git config --global user.name &quot;your name&quot;$ git config --global user.email &quot;email@example.com&quot; 注意:git config命令的–global参数，用了这个参数，表示你这台机器上所有的git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和email地址 创建版本库 版本库又名仓库，英文名repository 创建空目录1234$ mkdir learngit$ cd learngit$ pwd/users/michael/learngit pwd命令用于显示当前目录。在我的mac上，这个仓库位于/users/michael/learngit 为防止出现不可预知的bug,请使用英文目录 通过git init命令把这个目录变成git可以管理的仓库： 12$ git initinitialized empty git repository in /users/michael/learngit/.git/ 瞬间git就把仓库建好了，而且告诉你是一个空的仓库（empty git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把git仓库给破坏了。 如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。 把文件添加到版本库创建一个说明文件readme.txt,输入以下内容 12git is a version control system.git is free software. 第一步，用命令git add告诉git，把文件添加到仓库： 1$ git add readme.txt 第二步，用命令git commit告诉git，把文件提交到仓库： 1234$ git commit -m &quot;wrote a readme file&quot;[master (root-commit) cb926e7] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt 版本控制继续修改readme.txt文件 12git is a distributed version control system.git is free software. 使用git status命令当前状态： 123456789$ git status# on branch master# changes not staged for commit:# (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)# (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)## modified: readme.txt#no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 使用git diff命令查看修改内容: 123456789$ git diff readme.txt diff --git a/readme.txt b/readme.txtindex 46d49bf..9247db6 100644--- a/readme.txt+++ b/readme.txt@@ -1,2 +1,2 @@-git is a version control system.+git is a distributed version control system. git is free software. 提交版本第一步是git add： 1$ git add readme.txt 第二步git commit 1$ git commit -m &quot;add distributed&quot; 小结 要随时掌握工作区的状态，使用git status命令。 如果git status告诉你有文件被修改过，用git diff可以查看修改内容。 版本回退修改readme.txt内容: 12Git is a distributed version control system.Git is free software distributed under the GPL. 提交当前版本: 1234$ git add readme.txt$ git commit -m &quot;append GPL&quot;[master 3628164] append GPL 1 file changed, 1 insertion(+), 1 deletion(-) 使用git add对文件做修改 使用git commit创建版本序列 回顾以下提交过的历史版本:版本1：wrote a readme file 12Git is a version control system.Git is free software. 版本2：add distributed 12Git is a distributed version control system.Git is free software. 版本3：append GPL 12Git is a distributed version control system.Git is free software distributed under the GPL. 使用git log查看commit历史记录 123456789101112131415161718$ git logcommit 3628164fb26d48395383f8f31179f24e0882e1e0Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Tue Aug 20 15:11:49 2013 +0800 append GPLcommit ea34578d5496d7dd233c827ed32a8cd576c5ee85Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Tue Aug 20 14:53:12 2013 +0800 add distributedcommit cb926e7ea50ad11b8f9e909c05226233bf755030Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Mon Aug 19 17:51:55 2013 +0800 wrote a readme file 使用$ git log --pretty=oneline简化显示历史记录 1234$ git log --pretty=oneline3628164fb26d48395383f8f31179f24e0882e1e0 append GPLea34578d5496d7dd233c827ed32a8cd576c5ee85 add distributedcb926e7ea50ad11b8f9e909c05226233bf755030 wrote a readme file 在Git中，用HEAD表示当前版本，也就是最新的提交3628164…882e1e0（每个人的id不同），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 回退到上一个版本“add distributed”，使用git reset命令： 12$ git reset --hard HEAD^HEAD is now at ea34578 add distributed 查看readme.txt当前内容: 123$ cat readme.txtGit is a distributed version control system.Git is free software. 还可以继续回退到上一个版本wrote a readme file，不过且慢，然我们用git log再看看现在版本库的状态： 123456789101112$ git logcommit ea34578d5496d7dd233c827ed32a8cd576c5ee85Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Tue Aug 20 14:53:12 2013 +0800 add distributedcommit cb926e7ea50ad11b8f9e909c05226233bf755030Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Mon Aug 19 17:51:55 2013 +0800 wrote a readme file 只要上面的命令行窗口还没有被关掉,通过commit id可以回到未来版本: 12$ git reset --hard 3628164HEAD is now at 3628164 append GPL 即使关掉命令条,也可以通过git reflog命令查看版本操作记录: 12345$ git reflogea34578 HEAD@&#123;0&#125;: reset: moving to HEAD^3628164 HEAD@&#123;1&#125;: commit: append GPLea34578 HEAD@&#123;2&#125;: commit: add distributedcb926e7 HEAD@&#123;3&#125;: commit (initial): wrote a readme file 小结 HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 工作区和暂存区 git和其他版本控制系统如svn的不同之处就是有暂存区的概念 工作区(working directory)就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区： 版本库(repository)工作区的隐藏目录.git,就是git的版本库 git版本库中存了很多东西,其中最重要的就是stage(或称index)的暂存区,以及git自动创建的第一个分值master,还有指向master的指针head 向git版本库添加,分两步执行: git add,将文件添加到暂存区 git commit,将暂存区的内容提交到当前分支 因为git自动创建master分支,git commit就是想master分支提交更改 管理修改git是如何跟踪修改的，每次修改，如果不add到暂存区，那就不会加入到commit中。 git commit只会提交暂存区上的修改到分支上,如本地修改没有提交到暂存区,那同样不会提交到master分支上 撤消更改 本地做了修改,未提交到暂存区git checkout -- file可以丢弃工作区的修改： 1$ git checkout -- readme.txt 可以让这个文件回到最近一次git commit或git add时的状态 修改已添加到暂存区,未添加到分支用命令git reset head file可以把暂存区的修改撤销掉（unstage），重新放回工作区： 123$ git reset head readme.txtunstaged changes after reset:m readme.txt 小结场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset head file，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 删除文件命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。 命令rm可以删除本地文件 远程仓库添加远程仓库要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git； 关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而svn在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！ 克隆远程仓库要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。 git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。 分支管理创建与合并分支查看分支：git branch 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt; 创建+切换分支：git checkout -b &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt; 解决冲突git log --graph命令可以看到分支合并图 分支管理策略合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。 在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了 Bug分支突然接到任务需要放下工作修改bug分支,可以将工作区内容暂存(需要被git管理)1$ git stash 建立issue分支,修复big 查看暂存文件的列表1$ git stash list 修复完毕后取回暂存的文件12$ git stash apply //取出暂存文件但文件不删除$ git stash pop //取出暂存文件并删除 Feature分支开发一个新feature，最好新建一个分支； 如果要丢弃一个没有被合并过的分支，可以通过git branch -D 强行删除。 多人协作查看远程库信息12$ git remoteorigin 显示更详细的信息123$ git remote -vorigin git@github.com:michaelliao/learngit.git (fetch)origin git@github.com:michaelliao/learngit.git (push) 推送分支推送主分支:1$ git push origin master 推送其他分支:1$ git push origin dev 抓取分支1$ git clone git@github.com:michaelliao/learngit.git 要在dev分支上开发，就必须创建远程origin的dev分支到本地:1$ git checkout -b dev origin/dev 可以将dev上的修改push到远程:12$ git commit -m &quot;add /usr/bin/env&quot;$ git push origin dev 推送冲突远程库上最新提交和你试图推送的提交有冲突，Git提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送：1$ git pull git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接,再pull：1234567$ git branch --set-upstream dev origin/devBranch dev set up to track remote branch dev from origin.$ git pullAuto-merging hello.pyCONFLICT (content): Merge conflict in hello.pyAutomatic merge failed; fix conflicts and then commit the result. git pull成功，但是合并有冲突，需要手动解决:12$ git commit -m &quot;merge &amp; fix hello.py&quot;$ git push origin dev 多人协作的工作模式通常是这样： 首先，可以试图用git push origin branch-name推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并(失败的话需要对本地和远程分支做关联)； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！ 如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name。 这就是多人协作的工作模式，一旦熟悉了，就非常简单。 小结 查看远程库信息，使用git remote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致 建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name； 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 标签管理创建标签1$ git tag v1.0 用命令git tag查看所有标签：12$ git tagv1.0 命令git tag 用于新建一个标签，默认为HEAD，也可以指定一个commit id； git tag -a -m “blablabla…”可以指定标签信息； git tag -s -m “blablabla…”可以用PGP签名标签； 命令git tag可以查看所有标签。 操作标签 命令git push origin 可以推送一个本地标签； 命令git push origin –tags可以推送全部未推送过的本地标签； 命令git tag -d 可以删除一个本地标签； 命令git push origin :refs/tags/可以删除一个远程标签。 Fork参与开源项目在GitHub上，可以任意Fork开源仓库； 自己拥有Fork后的仓库的读写权限； 可以推送pull request给官方仓库来贡献代码 Git自定义忽略特殊文件在.gitignore文件内编写忽略列表 ex1:1234# Windows:Thumbs.dbehthumbs.dbDesktop.ini ex2:1234567# Python:*.py[cod]*.so*.egg*.egg-infodistbuild ex3:12345678910111213141516# Windows:Thumbs.dbehthumbs.dbDesktop.ini# Python:*.py[cod]*.so*.egg*.egg-infodistbuild# My configurations:db.inideploy_key_rsa 小结 忽略某些文件时，需要编写.gitignore； .gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理！ 配置别名使用st就表示status：1$ git config --global alias.st status 还有123$ git config --global alias.co checkout$ git config --global alias.ci commit$ git config --global alias.br branch 搭建Git服务器搭建Git服务器非常简单，通常10分钟即可完成； 要方便管理公钥，用Gitosis； 要像SVN那样变态地控制权限，用Gitolite。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[模块化、AMD、CMD的区别]]></title>
      <url>%2F2016%2F03%2F03%2FJavaScript%2F%E6%A8%A1%E5%9D%97%E5%8C%96%E3%80%81AMD%E3%80%81CMD%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[网上看到一篇关于模块化、AMD 和 CMD 的比较, 感觉不错, 整理了一下. 在JavaScript发展初期就是为了实现简单的页面交互逻辑，寥寥数语即可；如今CPU、浏览器性能得到了极大的提升，很多页面逻辑迁移到了客户端（表单验证等），随着web2.0时代的到来，Ajax技术得到广泛应用，jQuery等前端库层出不穷，前端代码日益膨胀. 这时候JavaScript作为嵌入式的脚本语言的定位动摇了，JavaScript却没有为组织代码提供任何明显帮助，甚至没有类的概念，更不用说模块（module）了，JavaScript极其简单的代码组织规范不足以驾驭如此庞大规模的代码. 模块化既然 JavaScript 不能管理庞大的代码库，我们可以借鉴一下其它语言是怎么处理大规模程序设计的，在Java中有一个重要带概念——package，逻辑上相关的代码组织到同一个包内，包内是一个相对独立的王国，不用担心命名冲突什么的，那么外部如果使用呢？直接import对应的package即可. 遗憾的是JavaScript在设计时定位原因，没有提供类似的功能，开发者需要模拟出类似的功能，来隔离、组织复杂的JavaScript代码，我们称为模块化。 一个模块就是实现特定功能的文件，有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。模块开发需要遵循一定的规范，各行其是就都乱套了 函数的封装我们在文件中编写几个函数, 就是一个模块化的雏形了. 1234567function fn1()&#123; statement&#125;function fn2()&#123; statement&#125; 但这样写有很大的缺点, 会污染全局变量, 可能出现命名冲突. 对象的方法为了解决上面问题，对象的写法应运而生，可以把所有的模块成员封装在一个对象中. 12345678910111213var myModule = &#123; var1: 1, var2: 2, fn1: function()&#123; &#125;, fn2: function()&#123; &#125;&#125; 这样避免了变量污染，只要保证模块名唯一即可，同时同一模块内的成员也有了关系. 看似不错的解决方案，但是也有缺陷，外部可以随意修改内部成员. 意外的修改可能导致全盘出错. 立即执行函数可以通过立即执行函数，来达到隐藏细节的目的 1234567891011121314151617var myModule = (function()&#123; var var1 = 1; var var2 = 2; function fn1()&#123; &#125; function fn2()&#123; &#125; return &#123; fn1: fn1, fn2: fn2 &#125;;&#125;)(); 这样在模块外部无法修改我们没有暴露出来的变量、函数 上述做法就是我们模块化的基础，目前，通行的JavaScript模块规范主要有两种：CommonJS和AMD CommonJS我们先从CommonJS谈起，因为在网页端没有模块化编程只是页面JavaScript逻辑复杂，但也可以工作下去，在服务器端却一定要有模块，所以虽然JavaScript在web端发展这么多年，第一个流行的模块化规范却由服务器端的JavaScript应用带来，CommonJS规范是由NodeJS发扬光大，这标志着JavaScript模块化编程正式登上舞台. 1、定义模块 根据CommonJS规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性. 2、模块输出： 模块只有一个出口，module.exports对象，我们需要把模块希望输出的内容放入该对象. 3、加载模块： 加载模块使用require方法，该方法读取一个文件并执行，返回文件内部的module.exports对象. require时的路径有不同要求，一般情况可以省略js拓展名，可以使用相对路径，也可以使用绝对路径，甚至可以省略路径直接使用模块名（前提是该模块是系统内置模块） 尴尬的浏览器仔细看上面的代码，会发现require是同步的。模块系统需要同步读取模块文件内容，并编译执行以得到模块接口. 这在服务器端实现很简单，也很自然，然而， 想在浏览器端实现问题却很多. 浏览器端，加载JavaScript最佳、最容易的方式是在document中插入script 标签.但脚本标签天生异步，传统CommonJS模块在浏览器环境中无法正常加载. 解决思路之一是，开发一个服务器端组件，对模块代码作静态分析，将模块与它的依赖列表一起返回给浏览器端。 这很好使，但需要服务器安装额外的组件，并因此要调整一系列底层架构. 另一种解决思路是，用一套标准模板来封装模块定义，但是对于模块应该怎么定义和怎么加载，又产生的分歧. AMDAMD 即Asynchronous Module Definition，中文名是异步模块定义的意思。它是一个在浏览器端模块化开发的规范. 由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎RequireJS，实际上AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出. requireJS主要解决两个问题 1、多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器 2、js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长 12345678910111213define(['dependency'], function () &#123; var name = 'Byron' function printName () &#123; console.log(name) &#125; return &#123; printName: printName &#125; &#125;)require(['myModule'], function (my) &#123; my.printName() &#125;) requireJS定义了一个函数 define，它是全局变量，用来定义模块. define(id?, dependencies?, factory); id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名） dependencies：是一个当前模块依赖的模块名称数组 factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值 在页面上使用require函数加载模块 require([dependencies], function(){});require()函数接受两个参数 第一个参数是一个数组，表示所依赖的模块 第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块 require()函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题. CMDCMD 即Common Module Definition通用模块定义，CMD规范是国内发展出来的，就像AMD有个requireJS，CMD有个浏览器的实现SeaJS，SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同. Sea.js 推崇一个模块一个文件，遵循统一的写法 define(id?, deps?, factory) 因为CMD推崇 一个文件一个模块，所以经常就用文件名作为模块id CMD推崇依赖就近，所以一般不在define的参数中写依赖，在factory中写 factory是一个函数，有三个参数，function(require, exports, module) require 是一个方法，接受 模块标识 作为唯一参数，用来获取其他模块提供的接口：require(id) exports 是一个对象，用来向外提供模块接口 module 是一个对象，上面存储了与当前模块相关联的一些属性和方法 12345678define(function(require, exports, module) &#123; var $ = require('jquery.js') $('div').addClass('active')&#125;)seajs.use(['myModule.js'], function(my)&#123;&#125;) AMD &amp; CMD 的区别最明显的区别就是在模块定义时对依赖的处理不同: AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块 CMD推崇就近依赖，只有在用到某个模块的时候再去require 这种区别各有优劣，只是语法上的差距，而且requireJS和SeaJS都支持对方的写法 AMD和CMD最大的区别是对依赖模块的执行时机处理不同，注意不是加载的时机或者方式不同 很多人说requireJS是异步加载模块，SeaJS是同步加载模块，这么理解实际上是不准确的，其实加载模块都是异步的，只不过AMD依赖前置，js可以方便知道依赖模块是谁，立即加载，而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略. 为什么我们说两个的区别是依赖模块执行时机不同，为什么很多人认为ADM是异步的，CMD是同步的（除了名字的原因。。。） 同样都是异步加载模块，AMD在加载模块完成后就会执行改模块，所有模块都加载执行完后会进入require的回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行. CMD加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的. 这也是很多人说AMD用户体验好，因为没有延迟，依赖模块提前执行了，CMD性能好，因为只有用户需要的时候才执行的原因]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[全局作用域中变量和函数名冲突时的优先级]]></title>
      <url>%2F2016%2F03%2F03%2FJavaScript%2FJavaScript-%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0%E5%90%8D%E5%86%B2%E7%AA%81%E6%97%B6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%2F</url>
      <content type="text"><![CDATA[全局作用域中变量和函数名冲突 全局作用域预解析时,如果变量与函数名相同,以函数为准 变量有赋值时,以变量为准 全局作用域变量名和函数名冲突123456789101112131415161718// 全局作用域变量名和函数名冲突// 1var a1=123;console.log(typeof a1); // numberfunction a1() &#123;&#125;// 2console.log(typeof a2); // functionvar a2=123;function a2() &#123;&#125;// 3var a3=123;function a3() &#123;&#125;console.log(typeof a3); // number// 4var a4;function a4() &#123;&#125;console.log(typeof a4); // functiona4=123; 预解析时,变量名、函数名、和传参冲突12345678910111213141516171819202122232425262728// 预解析时,变量名、函数名、和传参冲突 // 1.预解析,var a 先提升,实参给a赋值,后被222覆盖,输出222 function foo1(a)&#123; var a = 222; console.log(a); //222 &#125; foo1(111); // 2.预解析,var a 先提升,实参先给a赋值,输出111,后被222覆盖 function foo2(a)&#123; console.log(a); //111 var a = 222; &#125; foo2(111); // 3.变量已经被赋值,输出222 function foo3(a)&#123; var a = 222; console.log(a); //222 function a() &#123;&#125; &#125; foo3(111); // 3.变量没有被赋值时,输出a的函数体 function foo4(a)&#123; var a; console.log(a); //a的函数体 a = 222; function a() &#123;console.log("qwe")&#125; &#125; foo4(111);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[深复制与浅复制的区别]]></title>
      <url>%2F2016%2F03%2F02%2FJavaScript%2FJavaScript-%E6%B7%B1%E5%A4%8D%E5%88%B6%E4%B8%8E%E6%B5%85%E5%A4%8D%E5%88%B6%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[浅复制浅拷贝是指复制对象的时候，指对第一层键值对进行独立的复制。一个简单的实现如下：123456789101112131415// 浅复制实现function shadowCopy(target, source)&#123; if( !source || typeof source !== 'object')&#123; return; &#125; if( !target || typeof target !== 'object')&#123; return; &#125; // 这边最好区别一下对象和数组的复制 for(var key in source)&#123; if(source.hasOwnProperty(key))&#123; target[key] = source[key]; &#125; &#125;&#125; 我们分别对对象和数组进行测试，发现成功地复制了。123456789101112131415161718//测试例子var arr = [1,2,3];var arr2 = [];shadowCopy(arr2, arr);console.log(arr2);//[1,2,3]var today = &#123; weather: 'Sunny', date: &#123; week: 'Wed' &#125; &#125;var tomorrow = &#123;&#125;;shadowCopy(tomorrow, today);console.log(tomorrow);// Object &#123;weather: "Sunny", date: Object&#125; 对于date这个属性，tomorrow变量复制的是它在堆中的地址，这也导致了today和tomorrow的date其实是指向堆中的同一个对象,只是对地址的引用。 12345tomorrow.weather = 'Cloudy';tomorrow.date.week = 'Thurs';console.log(today.weather); // 'Sunny'console.log(today.date.week); //'Thurs' Array方法的slice，concat其实是一种浅复制 深复制深复制的实现,只需要再浅复制的基础上使用递归,复制所有属性和值1234567891011121314151617181920// 深复制实现function deepCopy(target, source)&#123; if( !source || typeof source !== 'object')&#123; return; &#125; if( !target || typeof target !== 'object')&#123; return; &#125; for(var key in source)&#123; if(source.hasOwnProperty(key))&#123; if( source[key] &amp;&amp; typeof source[key] == 'object')&#123; target[key] = &#123;&#125;; deepCopy(target[key], source[key]); &#125; else&#123; target[key] = source[key]; &#125; &#125; &#125; &#125; 深复制可以用JSON格式处理(ES5.API)12345678910111213var data=JSON.parse(JSON.stringify(obj))// 缺点:对于一般的需求是可以满足的，但是它有缺点。// 下例中，可以看到JSON复制会忽略掉值为undefined以及函数表达式。var obj = &#123; a: 1, b: 2, c: undefined, sum: function() &#123; return a + b; &#125;&#125;;var obj2 = JSON.parse(JSON.stringify(obj));console.log(obj2);//Object &#123;a: 1, b: 2&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[rem布局 body元素font-size初始化的必要性]]></title>
      <url>%2F2016%2F02%2F13%2FHTML%26CSS%2Ffont-size%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7%2F</url>
      <content type="text"><![CDATA[在我们进行rem布局时,通常给body设置font-size:14px或font-size:16px来进行初始化,今天来深究一下这是why? 什么是rem布局?我们通过给html元素设置font-size,并给元素设置rem单位,来响应不同手机端的缩放. body元素font-size初始化的必要性font-size是可以被后代元素继承的属性,如果不给body设置font-size值,html下后代元素都会继承html的font-size值.默认设置一般为100px,画风是不是有点奇怪呢. font-size除了影响文字大小,还会影响什么? 今天的重头戏来了,除了影响文字大小,还会影响什么呢? 布局中我们常注意到图片下多出的几像素,这个问题老生常谈了,原因我们已经知道,图片是默认对应baseline的. 前几日,有人找我review代码,有个问题:”input参数设置正确,为什么头顶还有一大片空白呢?” 画风是这样的: input元素未受到padding和margin影响,此时是初始位置 经过排查,是因为body没设置font-size,form元素继承html的字体大小了,那么问题来了,为什么font-size会对input元素产生影响? 大家应该想到之前img元素下方留白的问题了,其原理是一样的,行内元素都是沿font的baseline对齐的 如果font-size设置的过大,baseline就会下移,即使没有文字,行内元素也是会根据baseline走的,自然就出现位移的问题. 如何解决font-size对行内元素的影响? 我们这里讨论不止限于rem布局的方法 我们的目标是达到下图的效果: 行内元素转成块元素 12/*块元素自占一行*/display:block; 浮动 123/*脱离标准流*/float:left;float:right; 定位 123/*脱离标准流*/position:absolute;position:relative; vertical-align 12/*直接改变对齐方式*/vertical-align:top; 以上几种方法都可以解决这个问题]]></content>
    </entry>

    
  
  
</search>
