[{"title":"每日一句","date":"2017-04-21T04:55:36.000Z","path":"2017/04/21/dayily/REAMME/","text":"2017-4-21 12:55:36 Everyone has his inherent ability which is easily concealed by habits, blurred by time, and eroded by laziness. 每个人都有潜能，只是很容易被习惯所掩盖，被时间所迷离，被惰性所消磨。 2017-4-23 14:55:57 Don’t make promises when you’re joyful. Don’t reply when you’re sad. Don’t make decisions when you’re angry. ** 别在喜悦时承诺，别在悲伤时回答，别在愤怒时决定。","tags":[{"name":"外语","slug":"外语","permalink":"http://www.jixingchuan.com/tags/外语/"}]},{"title":"Github README","date":"2017-04-18T15:39:06.000Z","path":"2017/04/18/README/","text":"这里是我 Hexo 博客文章的源文件, 可以自由下载","tags":[]},{"title":"Javascript代码编程规范-Airbnb","date":"2017-04-04T05:25:22.000Z","path":"2017/04/04/works/Javascript代码编程规范-Airbnb/","text":"截止到本文发布,Airbub规范在GitHub上已经5万颗星了. 块级作用域（1）let取代varES6提出了两个新的声明变量的命令： let 和 const 。其中， let 完全可以取代 var ，因为两者语义相同，而且 let 没有副作用。1234567'use strict';if (true) &#123;let x = 'hello';&#125;for (let i = 0; i &lt; 10; i++) &#123;console.log(i);&#125; 上面代码如果用 var 替代 let ，实际上就声明了两个全局变量，这显然不是本意。变量应该只在其声明的代码块内有效， var 命令做不到这一点。var 命令存在变量提升效用， let 命令没有这个问题。 12345'use strict';if(true) &#123;console.log(x); // ReferenceErrorlet x = 'hello';&#125; 上面代码如果使用 var 替代 let ， console.log 那一行就不会报错，而是会输出 undefined ，因为变量声明提升到代码块的头部。这违反了变量先声明后使用的原则。所以，建议不再使用 var 命令，而是使用 let 命令取代。（2）全局常量和线程安全在 let 和 const 之间，建议优先使用 const ，尤其是在全局环境，不应该设置变量，只应设置常量。这符合函数式编程思想，有利于将来的分布503式运算。 12345678// badvar a = 1, b = 2, c = 3;// goodconst a = 1;const b = 2;const c = 3;// bestconst [a, b, c] = [1, 2, 3]; const 声明常量还有两个好处，一是阅读代码的人立刻会意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误。所有的函数都应该设置为常量。长远来看，JavaScript可能会有多线程的实现（比如Intel的River Trail那一类的项目），这时 let 表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全。504字符串静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。 123456789// badconst a = &quot;foobar&quot;;const b = &apos;foo&apos; + a + &apos;bar&apos;;// acceptableconst c = `foobar`;// goodconst a = &apos;foobar&apos;;const b = `foo$&#123;a&#125;bar`;const c = &apos;foobar&apos;; 解构赋值使用数组成员对变量赋值时，优先使用解构赋值。 123456const arr = [1, 2, 3, 4];// badconst first = arr[0];const second = arr[1];// goodconst [first, second] = arr; 函数的参数如果是对象的成员，优先使用解构赋值。 123456789101112// badfunction getFullName(user) &#123;const firstName = user.firstName;const lastName = user.lastName;&#125;// goodfunction getFullName(obj) &#123;const &#123; firstName, lastName &#125; = obj;&#125;// bestfunction getFullName(&#123; firstName, lastName &#125;) &#123;&#125; 如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。 12345678910// badfunction processInput(input) &#123;return [left, right, top, bottom];&#125;// good506function processInput(input) &#123;return &#123; left, right, top, bottom &#125;;&#125;const &#123; left, right &#125; = processInput(input); 507对象单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。 123456789101112// badconst a = &#123; k1: v1, k2: v2, &#125;;const b = &#123;k1: v1,k2: v2&#125;;// goodconst a = &#123; k1: v1, k2: v2 &#125;;const b = &#123;k1: v1,k2: v2,&#125;; 对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用 Object.assign 方法。 123456789// badconst a = &#123;&#125;;a.x = 3;// if reshape unavoidableconst a = &#123;&#125;;Object.assign(a, &#123; x: 3 &#125;);// goodconst a = &#123; x: null &#125;;a.x = 3; 如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。 1234567891011121314// badconst obj = &#123;508id: 5,name: &apos;San Francisco&apos;,&#125;;obj[getKey(&apos;enabled&apos;)] = true;// goodconst obj = &#123;id: 5,name: &apos;San Francisco&apos;,[getKey(&apos;enabled&apos;)]: true,&#125;; 上面代码中，对象 obj 的最后一个属性名，需要计算得到。这时最好采用属性表达式，在新建 obj 的时候，将该属性与其他属性定义在一起。这样一来，所有属性就在一个地方定义了。另外，对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。 1234567891011121314151617var ref = &apos;some value&apos;;// badconst atom = &#123;ref: ref,value: 1,addValue: function (value) &#123;return atom.value + value;&#125;,&#125;;// goodconst atom = &#123;ref,value: 1,addValue(value) &#123;return atom.value + value;&#125;,&#125;; 509数组使用扩展运算符（…）拷贝数组。 123456789// badconst len = items.length;const itemsCopy = [];let i;for (i = 0; i &lt; len; i++) &#123;itemsCopy[i] = items[i];&#125;// goodconst itemsCopy = [...items]; 使用Array.from方法，将类似数组的对象转为数组。 12const foo = document.querySelectorAll(&apos;.foo&apos;);const nodes = Array.from(foo); 510函数立即执行函数可以写成箭头函数的形式。 123(() =&gt; &#123;console.log(&apos;Welcome to the Internet.&apos;);&#125;)(); 那些需要使用函数表达式的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了this。 12345678910// bad[1, 2, 3].map(function (x) &#123;return x * x;&#125;);// good[1, 2, 3].map((x) =&gt; &#123;return x * x;&#125;);// best[1, 2, 3].map(x =&gt; x * x); 箭头函数取代 Function.prototype.bind ，不应再用self/_this/that绑定this。 12345678910// badconst self = this;const boundMethod = function(...params) &#123;return method.apply(self, params);&#125;// acceptableconst boundMethod = method.bind(this);// bestconst boundMethod = (...params) =&gt; method.apply(this,params); 511简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。 123456// badfunction divide(a, b, option = false ) &#123;&#125;// goodfunction divide(a, b, &#123; option = false &#125; = &#123;&#125;) &#123;&#125; 不要在函数体内使用arguments变量，使用rest运算符（…）代替。因为rest运算符显式表明你想要获取参数，而且arguments是一个类似数组的对象，而rest运算符可以提供一个真正的数组。 123456789// badfunction concatenateAll( ) &#123;const args = Array.prototype.slice.call(arguments);return args.join(&apos;&apos;);&#125;// goodfunction concatenateAll(...args) &#123;return args.join(&apos;&apos;);&#125; 使用默认值语法设置函数参数的默认值。 1234567// badfunction handleThings(opts) &#123;opts = opts || &#123;&#125;;&#125;// goodfunction handleThings(opts = &#123;&#125;) &#123;// ... }512Map结构注意区分Object和Map，只有模拟现实世界的实体对象时，才使用Object。如果只是需要 key: value 的数据结构，使用Map结构。因为Map有内建的遍历机制。 12345678910let map = new Map(arr);for (let key of map.keys()) &#123;console.log(key);&#125;for (let value of map.values()) &#123;console.log(value);&#125;for (let item of map.entries()) &#123;console.log(item[0], item[1]);&#125; Class总是用Class，取代需要prototype的操作。因为Class的写法更简洁，更易于理解。 1234567891011121314151617181920// badfunction Queue(contents = []) &#123;this._queue = [...contents];&#125;Queue.prototype.pop = function( ) &#123;const value = this._queue[0];this._queue.splice(0, 1);return value;&#125;// goodclass Queue &#123;constructor(contents = []) &#123;this._queue = [...contents];&#125;pop() &#123;const value = this._queue[0];this._queue.splice(0, 1);return value;&#125;&#125; 使用 extends 实现继承，因为这样更简单，不会有破坏 instanceof 运算的危险。 12345678910111213141516// badconst inherits = require(&apos;inherits&apos;);function PeekableQueue(contents) &#123;Queue.apply(this, contents);&#125;inherits(PeekableQueue, Queue);PeekableQueue.prototype.peek = function( ) &#123;return this._queue[0];&#125;// goodclass PeekableQueue extends Queue &#123;peek() &#123;return this._queue[0];&#125;&#125; 模块首先，Module语法是JavaScript模块的标准写法，坚持使用这种写法。使用 import 取代 require 。 1234567// badconst moduleA = require(&apos;moduleA&apos;);const func1 = moduleA.func1;const func2 = moduleA.func2;// goodimport &#123; func1, func2 &#125; from &apos;moduleA&apos;;使用 export 取代 module.exports 。 12345678910111213141516// commonJS的写法var React = require(&apos;react&apos;);var Breadcrumbs = React.createClass(&#123;render() &#123;return &lt;nav /&gt;;&#125;&#125;);module.exports = Breadcrumbs;// ES6的写法import React from &apos;react&apos;;const Breadcrumbs = React.createClass(&#123;render() &#123;return &lt;nav /&gt;;&#125;&#125;);export default Breadcrumbs 如果模块只有一个输出值，就使用 export default ，如果模块有多个输出值，就不使用 export default ，不要 export default 与普通的 export 同时使用。 不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default）。 1234// badimport * as myObject &apos;./importModule&apos;;// goodimport myObject from &apos;./importModule&apos;; 如果模块默认输出一个函数，函数名的首字母应该小写。 123function makeStyleGuide( ) &#123;&#125;export default makeStyleGuide; 如果模块默认输出一个对象，对象名的首字母应该大写。 12345const StyleGuide = &#123;es6: &#123;&#125;&#125;;export default StyleGuide;","tags":[{"name":"编程规范","slug":"编程规范","permalink":"http://www.jixingchuan.com/tags/编程规范/"}]},{"title":"怎么复制Window中CMD命令行中的内容","date":"2017-02-04T04:51:43.000Z","path":"2017/02/04/experiences/怎么复制Window中CMD命令行中的内容/","text":"Git bash和shell命令条默认都是可以复制内容的,Window的命令条却不行,有时候真的很麻烦. 在选项卡中把编辑模式改成快速编辑模式就可以了,只是不容易找到设置界面. 把鼠标放在CMD面板的上方的半透明条，右击出来右键菜单,点击”属性” 在编辑选项中选中”快速编辑模式”,”确定”保存设置 选中内容后,使用enter按键自动保存到剪切板,也可以右键菜单手动复制、粘贴","tags":[{"name":"terminal","slug":"terminal","permalink":"http://www.jixingchuan.com/tags/terminal/"}]},{"title":"前端可以做哪些优化","date":"2017-01-26T13:16:28.000Z","path":"2017/01/26/works/前端可以做哪些优化/","text":"网页打开的延时, 页面操作的流畅度, 就是一个网站的生命. 我们站在前端的角度, 都可以做哪些优化呢? 来自谷歌的 Web 优化实践 避免资源 404 请求 避免CSS @import import 依赖关系, 加载完一个再加载另一个 避免使用document.write 都用 HTML 来调用, 使用 document.write 浏览器还需要运行 JS 解析器分析下面要做什么 合并、压缩 CSS, JS文件 精灵图整合图像, 字体图标代替部分图片 延迟 JavaScript 加载 启用Keep-Alive 将小的CSS和JavaScript代码内嵌到HTML中 利用浏览器缓存不长变更的资源 尽量减少DNS查询次数 尽量减少重定向 优化样式表和脚本的顺序 避免JavaScripts阻塞渲染 缩小原始图像 指定图像尺寸 来自雅虎的 Web 优化实践 内容优化 避免资源 404 请求 减少 HTTP 请求 减少 DNS 查找 减少重定向 预加载组件 延迟加载脚本和内容 Ajax 缓存文件资源 减少 DOM 元素数量 根据域名划分页面内容 最小化 iframe 数量 服务器优化 使用 CDN 内容分发网络 添加Expires或Cache-Control信息头 Gzip 压缩 设置 Etag , 判断服务器与浏览器缓存中内容的一致性 提前刷新缓冲区 对Ajax请求使用GET方法 避免空的 src cookie 的优化 减少 cookie 的大小 针对Web组件使用域名无关的Cookie ( 突破 cookie 大小的限制 ) CSS 优化 将CSS代码放在HTML页面的顶部 避免使用CSS表达式 使用&lt;link&gt;来代替@import 避免使用Filters JavaScript 优化 将JavaScript脚本放在页面的底部 将JavaScript和CSS作为外部文件来引用 缩小JavaScript和CSS 删除重复的脚本 最小化DOM的访问 开发智能的事件处理程序 图像优化 优化图片大小 指定图片大小 使用精灵图 favicon 尽量小, 可缓存 针对移动优化 保持组件大小在 25KB 以下, iPhone 不能缓存 25KB 以上文件 打包组件 作者 : 纪行川 博客 : 行川草庐 声明 : 网站内容可自由转载 , 转载请附上作者信息和详细链接","tags":[{"name":"SEO","slug":"SEO","permalink":"http://www.jixingchuan.com/tags/SEO/"}]},{"title":"ES6常用语法","date":"2017-01-04T02:33:51.000Z","path":"2017/01/04/JavaScript/ES6常用语法/","text":"声明 : 此篇为转载内容 , 想详细学习 ES6 语法, 可以去拜读下阮一峰写的 ECMAScript 6 入门 ( 第二版 ) ECMAScript 6（以下简称ES6）是JavaScript语言的下一代标准。因为当前版本的ES6是在2015年发布的，所以又称ECMAScript 2015。 也就是说，ES6就是ES2015。虽然目前并不是所有浏览器都能兼容ES6全部特性，但越来越多的程序员在实际项目当中已经开始使用ES6了。所以就算你现在不打算使用ES6，但为了看懂别人的你也该懂点ES6的语法了…在我们正式讲解ES6语法之前，我们得先了解下Babel。 Babel Babel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。大家可以选择自己习惯的工具来使用使用Babel，具体过程可直接在Babel官网查看： 最常用的ES6特性 : let, const, class, extends, super, arrow functions, template string, destructuring, default, rest arguments 这些是ES6最常用的几个语法，基本上学会它们，我们就可以走遍天下都不怕啦！我会用最通俗易懂的语言和例子来讲解它们，保证一看就懂，一学就会。let, const这两个的用途与var类似，都是用来声明变量的，但在实际运用中他俩都有各自的特殊用途。首先来看下面这个例子： 123456789101112var name ='zach'while(true)&#123; var name ='obama' console.log(name) //obama break&#125;console.log(name) //obama 使用var 两次输出都是obama，这是因为ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。第一种场景就是你现在看到的内层变量覆盖外层变量。而let则实际上为JavaScript新增了块级作用域。用它所声明的变量，只在let命令所在的代码块内有效。 123456789let name ='zach' while(true)&#123; let name ='obama' console.log(name) //obama break&#125; console.log(name) //zach 另外一个var带来的不合理场景就是用来计数的循环变量泄露为全局变量，看下面的例子： 1234567var a =[];for(var i =0; i &lt;10; i++)&#123; a[i]=function()&#123; console.log(i); &#125;;&#125;a[6]();// 10 上面代码中，变量i是var声明的，在全局范围内都有效。所以每一次循环，新的i值都会覆盖旧值，导致最后输出的是最后一轮的i的值。而使用let则不会出现这个问题。 1234567var a =[];for(let i =0; i &lt;10; i++)&#123; a[i]=function()&#123; console.log(i); &#125;;&#125;a[6]();// 6 再来看一个更常见的例子，了解下如果不用ES6，而用闭包如何解决这个问题。 123456var clickBoxs = document.querySelectorAll('.clickBox')for(var i =0; i &lt; clickBoxs.length; i++)&#123; clickBoxs[i].onclick =function()&#123; console.log(i) &#125;&#125; 我们本来希望的是点击不同的clickBox，显示不同的i，但事实是无论我们点击哪个clickBox，输出的都是5。下面我们来看下，如何用闭包搞定它。 12345678910function iteratorFactory(i)&#123; var onclick =function(e)&#123; console.log(i) &#125; return onclick;&#125;var clickBoxs = document.querySelectorAll('.clickBox')for(var i =0; i &lt; clickBoxs.length; i++)&#123; clickBoxs[i].onclick = iteratorFactory(i)&#125; const也用来声明变量，但是声明的是常量。一旦声明，常量的值就不能改变。 当我们尝试去改变用const声明的常量时，浏览器就会报错。const有一个很好的应用场景，就是当我们引用第三方库的时声明的变量，用const来声明可以避免未来不小心重命名而导致出现bug：1const monent =require(&apos;moment&apos;) class, extends, super这三个特性涉及了ES5中最令人头疼的的几个部分：原型、构造函数，继承…你还在为它们复杂难懂的语法而烦恼吗？你还在为指针到底指向哪里而纠结万分吗？有了ES6我们不再烦恼！ ES6提供了更接近传统语言的写法，引入了Class（类）这个概念。新的class写法让对象原型的写法更加清晰、更像面向对象编程的语法，也更加通俗易懂。 123456789101112131415161718192021classAnimal&#123; constructor()&#123; this.type ='animal' &#125; says(say)&#123; console.log(this.type +' says '+ say) &#125;&#125; let animal =newAnimal()animal.says('hello')//animal says hello classCatextendsAnimal&#123; constructor()&#123; super() this.type ='cat' &#125;&#125; let cat =newCat()cat.says('hello')//cat says hello 上面代码首先用class定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。简单地说，constructor内定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实例对象可以共享的。Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。上面定义了一个Cat类，该类通过extends关键字，继承了Animal类的所有属性和方法。 super关键字，它指代父类的实例（即父类的this对象）。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。ES6的继承机制，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。P.S 如果你写react的话，就会发现以上三个东西在最新版React中出现得很多。创建的每个component都是一个继承React.Component的类。详见react文档arrow function这个恐怕是ES6最最常用的一个新特性了，用它来写function比原来的写法要简洁清晰很多: 12function(i)&#123;return i +1;&#125;//ES5(i)=&gt; i +1//ES6 简直是简单的不像话对吧…如果方程比较复杂，则需要用{}把代码包起来：123456function(x, y)&#123; x++; y--; return x + y;&#125;(x, y)=&gt;&#123;x++; y--;return x+y&#125; 除了看上去更简洁以外，arrow function还有一项超级无敌的功能！长期以来，JavaScript语言的this对象一直是一个令人头痛的问题，在对象方法中使用this，必须非常小心。例如：12345678910111213classAnimal&#123; constructor()&#123; this.type ='animal' &#125; says(say)&#123; setTimeout(function()&#123; console.log(this.type +' says '+ say) &#125;,1000) &#125;&#125; var animal =newAnimal() animal.says('hi') //undefined says hi 运行上面的代码会报错，这是因为setTimeout中的this指向的是全局对象。所以为了让它能够正确的运行，传统的解决方法有两种：第一种是将this传给self,再用self来指代this12345says(say)&#123; varself=this; setTimeout(function()&#123; console.log(self.type +' says '+ say) &#125;,1000) 第二种方法是用bind(this),即1234says(say)&#123; setTimeout(function()&#123; console.log(this.type +' says '+ say) &#125;.bind(this),1000) 但现在我们有了箭头函数，就不需要这么麻烦了：123456789101112classAnimal&#123; constructor()&#123; this.type ='animal' &#125; says(say)&#123; setTimeout(()=&gt;&#123; console.log(this.type +' says '+ say) &#125;,1000) &#125;&#125;var animal =newAnimal() animal.says('hi') //animal says hi 当我们使用箭头函数时，函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，它的this是继承外面的，因此内部的this就是外层代码块的this。template string这个东西也是非常有用，当我们要插入大段的html内容到文档中时，传统的写法非常麻烦，所以之前我们通常会引用一些模板工具库，比如mustache等等。大家可以先看下面一段代码：123456$(\"#result\").append( \"There are &lt;b&gt;\"+ basket.count +\"&lt;/b&gt; \"+ \"items in your basket, \"+ \"&lt;em&gt;\"+ basket.onSale + \"&lt;/em&gt; are on sale!\"); 我们要用一堆的’+’号来连接文本与变量，而使用ES6的新特性模板字符串“后，我们可以直接这么来写：12345$(\"#result\").append(` There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt; are on sale!`); 用反引号（\\）来标识起始，用${}来引用变量，而且所有的空格和缩进都会被保留在输出之中，是不是非常爽？！React Router`从第1.0.3版开始也使用ES6语法了，比如这个例子：1&lt;Linkto=&#123;`/taco/$&#123;taco.name&#125;`&#125;&gt;&#123;taco.name&#125;&lt;/Link&gt; destructuring ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。看下面的例子：1234let cat ='ken'let dog ='lili'let zoo =&#123;cat: cat, dog: dog&#125;console.log(zoo) //Object &#123;cat: \"ken\", dog: \"lili\"&#125; 用ES6完全可以像下面这么写：1234let cat ='ken'let dog ='lili'let zoo =&#123;cat, dog&#125;console.log(zoo) //Object &#123;cat: \"ken\", dog: \"lili\"&#125; 反过来可以这么写：123let dog =&#123;type:'animal', many:2&#125;let&#123; type, many&#125;= dogconsole.log(type, many) //animal 2 default, restdefault很简单，意思就是默认值。大家可以看下面的例子，调用animal()方法时忘了传参数，传统的做法就是加上这一句type = type || ‘cat’ 来指定默认值。12345function animal(type)&#123; type = type ||'cat' console.log(type)&#125;animal() 如果用ES6我们而已直接这么写：1234function animal(type ='cat')&#123; console.log(type)&#125;animal() 最后一个rest语法也很简单，直接看例子：1234function animals(...types)&#123; console.log(types)&#125;animals('cat','dog','fish')//[\"cat\", \"dog\", \"fish\"] 而如果不用ES6的话，我们则得使用ES5的arguments。import export这两个家伙对应的就是es6自己的module功能。我们之前写的Javascript一直都没有模块化的体系，无法将一个庞大的js工程拆分成一个个功能相对独立但相互依赖的小工程，再用一种简单的方法把这些小工程连接在一起。 这有可能导致两个问题： 一方面js代码变得很臃肿，难以维护 另一方面我们常常得很注意每个script标签在html中的位置，因为它们通常有依赖关系，顺序错了可能就会出bug 在es6之前为解决上面提到的问题，我们得利用第三方提供的一些方案，主要有两种CommonJS(服务器端)和AMD（浏览器端，如require.js）。 而现在我们有了es6的module功能，它实现非常简单，可以成为服务器和浏览器通用的模块解决方案。 ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西。上面的设计思想看不懂也没关系，咱先学会怎么用，等以后用多了、熟练了再去研究它背后的设计思想也不迟！好，那我们就上代码… 传统的写法首先我们回顾下require.js的写法。假设我们有两个js文件: index.js和content.js,现在我们想要在index.js中使用content.js返回的结果，我们要怎么做呢？首先定义：1234//content.jsdefine('content.js',function()&#123; return'A cat';&#125;) 然后require：1234//index.jsrequire(['./content.js'],function(animal)&#123; console.log(animal); //A cat&#125;) 那CommonJS是怎么写的呢？12345//index.jsvar animal =require('./content.js')//content.jsmodule.exports ='A cat' ES6的写法12345//index.jsimport animal from'./content' //content.jsexportdefault'A cat' 以上我把三者都列出来了，妈妈再也不用担心我写混淆了…ES6 module的其他高级用法1234567//content.js exportdefault'A cat' exportfunction say()&#123; return'Hello!'&#125; exportconst type ='dog' 上面可以看出，export命令除了输出变量，还可以输出函数，甚至是类（react的模块基本都是输出类）12345//index.js import&#123; say, type &#125;from'./content' let says = say()console.log(`The $&#123;type&#125; says $&#123;says&#125;`) //The dog says Hello 这里输入的时候要注意：大括号里面的变量名，必须与被导入模块（content.js）对外接口的名称相同。如果还希望输入content.js中输出的默认值(default), 可以写在大括号外面。123456//index.js import animal,&#123; say, type &#125;from'./content' let says = say()console.log(`The $&#123;type&#125; says $&#123;says&#125; to $&#123;animal&#125;`) //The dog says Hello to A cat 修改变量名此时我们不喜欢type这个变量名，因为它有可能重名，所以我们需要修改一下它的变量名。在es6中可以用as实现一键换名。123456//index.js import animal,&#123; say, type as animalType &#125;from'./content' let says = say()console.log(`The $&#123;animalType&#125; says $&#123;says&#125; to $&#123;animal&#125;`) //The dog says Hello to A cat 模块的整体加载除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。123456//index.js import animal,*as content from'./content' let says = content.say()console.log(`The $&#123;content.type&#125; says $&#123;says&#125; to $&#123;animal&#125;`) //The dog says Hello to A cat 通常星号*结合as一起使用比较合适。终极秘籍考虑下面的场景：上面的content.js一共输出了三个变量（default, say, type）,假如我们的实际项目当中只需要用到type这一个变量，其余两个我们暂时不需要。我们可以只输入一个变量：1import&#123; type &#125;from'./content' 由于其他两个变量没有被使用，我们希望代码打包的时候也忽略它们，抛弃它们，这样在大项目中可以显著减少文件的体积。 ES6帮我们实现了！ 不过，目前无论是webpack还是browserify都还不支持这一功能… 如果你现在就想实现这一功能的话，可以尝试使用rollup.js 他们把这个功能叫做Tree-shaking，哈哈哈，意思就是打包前让整个文档树抖一抖，把那些并未被依赖或使用的东西统统抖落下去。。。 看看他们官方的解释吧： 总结以上就是ES6最常用的一些语法，可以说这20%的语法，在ES6的日常使用中占了80%…","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.jixingchuan.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://www.jixingchuan.com/tags/ES6/"}]},{"title":"移动web开发之viewport","date":"2016-08-07T07:15:51.000Z","path":"2016/08/07/mobile/移动web开发之viewport/","text":"为了移动多终端适配，苹果提出viewport的概念，并在Safari上推行，目前各厂商均已实现适配 开启viewport浏览器默认不开启viewport,如要开启viewport,需要再head标签中加入以下内容1&lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt; 让viewport的宽度等于设备宽度,不允许设备缩放,防止误触破坏界面效果,默认同时也是最大缩放比限制在1.0 emmet语法支持meta:vp+tab快捷输出 viewport属性在苹果的规范中，meta viewport 有6个属性，如下： width 设置layout viewport的宽度，为一个正整数，或设置字符串”width-device”,让其等于设备宽度,实现自适应 initial-scale 设置页面的初始缩放值，为一个数字，可以带小数 minimum-scale 允许用户的最小缩放值，为一个数字，可以带小数 maximum-scale 允许用户的最大缩放值，为一个数字，可以带小数 height 设置layout viewport的高度，很少使用 user-scalable 是否允许用户进行缩放,no代表不允许,yes代表允许 这些属性可以同时使用，也可以单独使用或混合使用，多个属性同时使用时用逗号隔开就行了。","tags":[{"name":"移动端","slug":"移动端","permalink":"http://www.jixingchuan.com/tags/移动端/"}]},{"title":"Apple ID更换主显邮箱后不能注销iCloud账号","date":"2016-07-02T12:57:11.000Z","path":"2016/07/02/experiences/Apple ID更换主显邮箱后不能注销iCloud账号/","text":"多年前入手了一台ipad mini2,主要用来看电影、煲剧. Apple id绑定的是163邮箱,因为历史原因,邮箱绑定的手机号无法更换了,所以换了一个邮箱. 结果悲剧的情况来了,ipad上iCloud账号还是显示原来的163邮箱,输入任何密码都提示错误,无法注销! 联系apple客服,和我说了半天,说他也没遇到这个情况,让我准备发票、保修卡等购物凭证再联系他们. 买了好几年了,早不知道放到哪里去了,卒~ 尝试了一些方法,终于解决了这个问题. 在这里说明一下,防止有其他人掉这个坑里爬不出来. 如果你有发票等购物凭证,而且原邮箱无法接收邮件,联系苹果客服处理吧,虽然繁琐,不过是可以解决的 如果你没有发票,原邮箱可以接收邮件,把Apple ID的主显邮箱改回原邮箱,注销掉所有设备上登录的账号,再更改邮箱 如果你什么都没有,自求多福吧 (。・_・)/ 我用的第二种解决方案,这里我要吐槽一下网易邮箱,手机号忘记更换,申诉了几年一直失败,苹果发来的邮件163邮箱给你自动加密,必须要手机验证码才能查看,所以之前一直没法改,最近突然发现不加密了,才解决这个问题. 这里提醒各位,常用的邮箱,或者你打算长期持有的邮箱地址,绑定手机号一直要实时更新. 特别网易邮箱,很多用户手机号忘记更换,几年都申诉不回来.","tags":[{"name":"Apple ID","slug":"Apple-ID","permalink":"http://www.jixingchuan.com/tags/Apple-ID/"},{"name":"iCloud","slug":"iCloud","permalink":"http://www.jixingchuan.com/tags/iCloud/"}]},{"title":"Harmony(ES3.1改版)学习总结","date":"2016-06-10T01:53:44.000Z","path":"2016/06/10/JavaScript/Harmony(ES3.1改版)学习总结/","text":"变量声明 let 只在当前块级作用域中有效 let语句:只能在后续代码块中使用的变量 12345var num = 5;let (num=10, multiplier=2)&#123;alert(num * multiplier); //20&#125;alert(num); //5 let 表达式: 123var result = let(num=10, multiplier=2) num * multiplier;alert(result); //20//这里的 let 表达式使用两个变量计算后得到一个值，保存在变量 result中。执行表达式之后， num和 multiplier 变量就不存在了。 const 常量,声明后不能再更改其中的值 函数剩余参数与分布参数 剩余参数 ( rest arguments ) 剩余参数的语法形式是三个点后跟一个标识符...nums 123456789function sum(num1, num2, ...nums)&#123;var result = num1 + num2;for (let i=0, len=nums.length; i &lt; len; i++)&#123;result += nums[i];&#125;return result;&#125;var result = sum(1, 2, 3, 4, 5, 6);console.log(result) //21 分布参数（spread arguments） 通过分布参数，可以向函数中传入一个数组，然后数组中的元素会映射到函数的每个参数上 分布参数的语法形式与剩余参数的语法相同，就是在值的前面加三个点。唯一的区别是分布参数在调用函数的时候使用，而剩余参数在定义函数的时候使用 1var result = sum(...[1, 2, 3, 4, 5, 6]); 1var result = sum.apply(null, [1, 2, 3, 4, 5, 6]); 参数默认值要为参数指定默认值，可以在参数名后面直接加上等于号和默认值12345function sum(num1, num2=0)&#123;return num1 + num2;&#125;var result1 = sum(5);var result2 = sum(5, 5); 生成器对 Harmony 而言，要创建生成器，可以让函数通过 yield 操作符返回某个特殊的值。对于使用 yield操作符返回值的函数，调用它时就会创建并返回一个新的 Generator 实例。然后，在这个实例上调用 next() 方法就能取得生成器的第一个值。此时，执行的是原来的函数，但执行流到 yield 语句就会停止，只返回特定的值。从这个角度看， yield 与 return 很相似。如果再次调用 next() 方法，原来函数中位于 yield 语句后的代码会继续执行，直到再次遇见 yield 语句时停止执行，此时再返回一个新值 123456789101112131415function myNumbers()&#123;for (var i=0; i &lt; 10; i++)&#123;yield i * 2;&#125;&#125;var generator = myNumbers();try &#123;while(true)&#123;document.write(generator.next() + \"&lt;br /&gt;\");&#125;&#125; catch(ex)&#123;//有意没有写代码&#125; finally &#123;generator.close();&#125; 数组及其他结构迭代器要为对象创建迭代器，可以调用 Iterator 构造函数，传入想要迭代其值的对象。要取得对象中的下一个值，可以调用迭代器的 next() 方法12345678910111213var person = &#123;name: &quot;Nicholas&quot;,age: 29&#125;;var iterator = new Iterator(person);try &#123; while(true)&#123; let value = iterator.next(); document.write(value.join(&quot;:&quot;) + &quot;&lt;br&gt;&quot;);&#125;&#125; catch(ex)&#123;//有意没有写代码&#125; 数组领悟JavaScript 中数组领悟的基本形式如下：1array = [ value for each (variable in values) condition ]; 12345678910//原始数组var numbers = [0,1,2,3,4,5,6,7,8,9,10];//把所有元素复制到新数组var duplicate = [i for each (i in numbers)];//只把偶数复制到新数组var evens = [i for each (i in numbers) if (i % 2 == 0)];//把每个数乘以 2 后的结果放到新数组中var doubled = [i*2 for each (i in numbers)];//把每个奇数乘以 3 后的结果放到新数组中var tripledOdds = [i*3 for each (i in numbers) if (i % 2 &gt; 0)]; 待续发现很多属性和方法已经不可用了,暂时先看到这里","tags":[{"name":"Harmony","slug":"Harmony","permalink":"http://www.jixingchuan.com/tags/Harmony/"},{"name":"ES3.1","slug":"ES3-1","permalink":"http://www.jixingchuan.com/tags/ES3-1/"}]},{"title":"setTimeout的秘密","date":"2016-06-03T06:21:36.000Z","path":"2016/06/03/JavaScript/setTimeout的秘密/","text":"计时器setTimeout是我们经常会用到的，它用于在指定的毫秒数后调用函数或计算表达式。 语法： setTimeout(code, millisec, args); 注意：如果code为字符串，相当于执行eval()方法来执行code。 当然，这一篇文章并不仅仅告诉你怎么用setTimeout，而且理解其是如何执行的。 1、setTimeout原理先来看一段代码： 1234567891011varstart = newDate(); varend = 0; setTimeout(function()&#123; console.log(newDate() - start); &#125;, 500); while(newDate() - start &lt;= 1000)&#123;&#125; 在上面的代码中，定义了一个setTimeout定时器，延时时间是500毫秒。 你是不是觉得打印结果是： 500 可事实却是出乎你的意料，打印结果是这样的（也许你打印出来会不一样，但肯定会大于1000毫秒）： 这是为毛呢？ 究其原因，这是因为 JavaScript是单线程执行的。也就是说，在任何时间点，有且只有一个线程在运行JavaScript程序，无法同一时候运行多段代码。 再来看看浏览器下的JavaScript。 浏览器的内核是多线程的，它们在内核控制下相互配合以保持同步，一个浏览器至少实现三个常驻线程：JavaScript引擎线程，GUI渲染线程，浏览器事件触发线程。 * JavaScript引擎是基于事件驱动单线程执行的，JavaScript引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个JavaScript线程在运行JavaScript程序。 * GUI渲染线程负责渲染浏览器界面，当界面需要重绘（Repaint）或由于某种操作引发回流(Reflow)时，该线程就会执行。但需要注意，GUI渲染线程与JavaScript引擎是互斥的，当JavaScript引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JavaScript引擎空闲时立即被执行。 * 事件触发线程，当一个事件被触发时，该线程会把事件添加到待处理队列的队尾，等待JavaScript引擎的处理。这些事件可来自JavaScript引擎当前执行的代码块如setTimeout、也可来自浏览器内核的其他线程如鼠标点击、Ajax异步请求等，但由于JavaScript的单线程关系，所有这些事件都得排队等待JavaScript引擎处理（当线程中没有执行任何同步代码的前提下才会执行异步代码）。 到这里，我们再来回顾一下最初的例子： 1234567891011varstart = newDate(); varend = 0; setTimeout(function()&#123; console.log(newDate() - start); &#125;, 500); while(newDate() - start &lt;= 1000)&#123;&#125; 虽然setTimeout的延时时间是500毫秒，可是由于while循环的存在，只有当间隔时间大于1000毫秒时，才会跳出while循环，也就是说，在1000毫秒之前，while循环都在占据着JavaScript线程。也就是说，只有等待跳出while后，线程才会空闲下来，才会去执行之前定义的setTimeout。 最后 ，我们可以总结出，setTimeout只能保证在指定的时间后将任务(需要执行的函数)插入任务队列中等候，但是不保证这个任务在什么时候执行。一旦执行javascript的线程空闲出来，自行从队列中取出任务然后执行它。 因为javascript线程并没有因为什么耗时操作而阻塞，所以可以很快地取出排队队列中的任务然后执行它，也是这种队列机制，给我们制造一个异步执行的假象。 2、setTimeout的好搭档“0”也许你见过下面这一段代码： 12345setTimeout(function()&#123; // statement &#125;,0); 上面的代码表示立即执行。 本意是立刻执行调用函数，但事实上，上面的代码并不是立即执行的，这是因为setTimeout有一个最小执行时间，当指定的时间小于该时间时，浏览器会用最小允许的时间作为setTimeout的时间间隔，也就是说即使我们把setTimeout的延迟时间设置为0，被调用的程序也没有马上启动。 不同的浏览器实际情况不同，IE8和更早的IE的时间精确度是15.6ms。不过，随着HTML5的出现，在高级版本的浏览器（Chrome、ie9+等），定义的最小时间间隔是不得低于4毫秒，如果低于这个值，就会自动增加，并且在2010年及之后发布的浏览器中采取一致。 所以说，当我们写为 setTimeout(fn,0) 的时候，实际是实现插队操作，要求浏览器“尽可能快”的进行回调，但是实际能多快就完全取决于浏览器了。 那setTimeout(fn, 0)有什么用处呢？其实用处就在于我们可以改变任务的执行顺序！因为浏览器会在执行完当前任务队列中的任务，再执行setTimeout队列中积累的的任务。 通过设置任务在延迟到0s后执行，就能改变任务执行的先后顺序，延迟该任务发生，使之异步执行。 来看一个网上很流行的例子： 12345678document.querySelector('#one input').onkeydown = function()&#123; document.querySelector('#one span').innerHTML = this.value; &#125;; document.querySelector('#second input').onkeydown = function()&#123; setTimeout(function()&#123; document.querySelector('#second span').innerHTML = document.querySelector('#second input').value; &#125;,0);&#125;; 当你往两个表单输入内容时，你会发现未使用setTimeout函数的只会获取到输入前的内容，而使用setTimeout函数的则会获取到输入的内容。 这是为什么呢？ 因为当按下按键的时候，JavaScript 引擎需要执行 keydown 的事件处理程序，然后更新文本框的 value 值，这两个任务也需要按顺序来，事件处理程序执行时，更新 value值（是在keypress后）的任务则进入队列等待，所以我们在 keydown 的事件处理程序里是无法得到更新后的value的，而利用 setTimeout(fn, 0)，我们把取 value 的操作放入队列，放在更新 value 值以后，这样便可获取出文本框的值。 未使用setTimeout函数，执行顺序是：onkeydown =&gt; onkeypress =&gt; onkeyup 使用setTimeout函数，执行顺序是：onkeydown =&gt; onkeypress =&gt; function =&gt; onkeyup 虽然我们可以使用keyup来替代keydown，不过有一些问题，那就是长按时，keyup并不会触发。 长按时，keydown、keypress、keyup的调用顺序： keydown keypress keydown keypress … keyup 也就是说keyup只会触发一次，所以你无法用keyup来实时获取值。 我们还可以用setImmediate()来替代setTimeout(fn,0)： if(!window.setImmediate){ window.setImmediate = function(func,args){ returnwindow.setTimeout(func,0,args); }; window.clearImmediate = window.clearTimeout;} setImmediate()方法用来把一些需要长时间运行的操作放在一个回调函数里，在浏览器完成后面的其他语句后，就立刻执行这个回调函数，必选的第一个参数func，表示将要执行的回调函数，它并不需要时间参数。 注意：目前只有IE10支持此方法，当然，在Nodejs中也可以调用此方法。 3、setTimeout的一些秘密3.1 setTimeout中回调函数的this由于setTimeout() 方法是浏览器 window 对象提供的，因此第一个参数函数中的this其实是指向window对象，这跟变量的作用域有关。 看个例子： 12345678910vara = 1; varobj = &#123; a: 2, test: function()&#123; setTimeout(function()&#123; console.log(this.a); &#125;,0); &#125; &#125;; obj.test(); // 1 不过我们可以通过使用bind()方法来改变setTimeout回调函数里的this 12345678910vara = 1; varobj = &#123; a: 2, test: function()&#123; setTimeout(function()&#123; console.log(this.a); &#125;.bind(this),0); &#125; &#125;; obj.test(); // 2 3.2 setTimeout不止两个参数我们都知道，setTimeout的第一个参数是要执行的回调函数，第二个参数是延迟时间（如果省略，会由浏览器自动设置。在IE，FireFox中，第一次配可能给个很大的数字，100ms上下，往后会缩小到最小时间间隔，Safari，chrome，opera则多为10ms上下。） 其实，setTimeout可以传入第三个参数、第四个参数….，它们表示神马呢？其实是用来表示第一个参数（回调函数）传入的参数。 1234setTimeout(function(a,b)&#123; console.log(a); // 3 console.log(b); // 4&#125;,0,3,4);","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.jixingchuan.com/tags/JavaScript/"},{"name":"事件队列","slug":"事件队列","permalink":"http://www.jixingchuan.com/tags/事件队列/"}]},{"title":"解决谷歌账户注册手机号无法重用的问题","date":"2016-05-04T04:13:37.000Z","path":"2016/05/04/experiences/解决谷歌账户注册手机号无法重用的问题/","text":"昨天准备新注册个谷歌账户做公事用途,提示我的手机号已注册过手机服务. 我用的是新手机号,确认自己没用它注册过谷歌账户,但以前手机账户持有人就说不定了. 翻阅无数帖子,终于发现了一个解决办法. 在Android、IOS手机端下载QQ邮箱或者网易邮箱大师等第三方邮箱管理App, 安装完邮箱App后,添加Gmail账户,会自动跳转到Gmail登录界面, 点击登录界面的”新建账户”按钮,填写信息即可成功注册.","tags":[{"name":"Google","slug":"Google","permalink":"http://www.jixingchuan.com/tags/Google/"}]},{"title":"bower基本使用","date":"2016-04-29T05:25:26.000Z","path":"2016/04/29/tools/bower基本使用/","text":"bower是什么?bower是基于nodejs的静态资源管理工具,由twitter公司开发、维护,使用它可以方便的安装、更新、卸载前端类库,同时解决类库之前的依赖关系. 依赖环境bower依赖于nodejs和git,bower是通过内置的映射表从GitHub上下载类库到本地 安装打开Window命令条窗口,输入以下命令,完成全局安装,-g是全局(global)安装的意思 1npm install -g bower 显示版本号则安装成功 1bower -v 输入上面的指令查看bower当前版本号,我的是”1.8.0”. 映射表查询如果我们想下载jquery-cookie,但不知道bower内置的映射表对应的名称,可以通过以下git指令查询 1$bower search jquery-cookie git窗口会显示以下信息,这就是bower内部设置的映射关系 12345678910Search results: jquery.cookie https://github.com/carhartl/jquery-cookie.git jquery-cookie https://github.com/carhartl/jquery-cookie.git hg-jquery-cookie https://github.com/hackergaucho/hg-jquery-cookie.git jquery-cookie-consent https://github.com/smichaelsen/jquery-cookie-consent.git jquery-cookie-banner https://github.com/alberon/jquery-cookie-banner.git jquery-cookie-alerter https://github.com/siliconsalad/jquery-cookie-alerter.git jaaulde-jquery-cookies https://github.com/JAAulde/jquery-cookies.git jquery-cookie-disclaimer https://github.com/Gix075/cookieDisclaimer.git 类库本地安装知道了映射关系,我们就可以安装类库了 1$ bower install jquery-cookie 在打开git的路径下,自动创建bower_components文件夹,下载jquery-cookie和它依赖的库jquery 类库卸载通过uninstall命令卸载 1$ bower uninstall jquery-cookie 查询类库历史版本1$ bower info jquery git窗口会显示类库详细的历史版本号,默认安装是最新版本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&#123; name: &apos;jquery&apos;, main: &apos;dist/jquery.js&apos;, license: &apos;MIT&apos;, ignore: [ &apos;package.json&apos; ], keywords: [ &apos;jquery&apos;, &apos;javascript&apos;, &apos;browser&apos;, &apos;library&apos; ], homepage: &apos;https://github.com/jquery/jquery-dist&apos;, version: &apos;3.2.1&apos;&#125;Available versions: - 3.2.1 - 3.2.0 - 3.1.1 - 3.1.0 - 3.0.0 - 2.2.4 - 2.2.3 - 2.2.2 - 2.2.1 - 2.2.0 - 2.1.4 - 2.1.3 - 2.1.2 - 2.1.1 - 2.1.0 - 2.0.3 - 2.0.2 - 2.0.1 - 2.0.0 - 1.12.4 - 1.12.3 - 1.12.2 - 1.12.1 - 1.12.0 - 1.11.3 - 1.11.2 - 1.11.1 - 1.11.0 - 1.10.2 - 1.10.1 - 1.10.0 - 1.9.1 - 1.9.0 - 1.8.3 - 1.8.2 - 1.8.1 - 1.8.0 - 1.7.2 - 1.7.1 - 1.7.0 - 1.6.4 - 1.6.3 - 1.6.2 - 1.6.1 - 1.6.0 - 1.5.2 - 1.5.1 - 1.5.0 - 1.4.4 - 1.4.3 - 1.4.2 - 1.4.1 - 1.4.0 - 1.3.2 - 1.3.1 - 1.3.0 - 1.2.6 - 1.2.5 - 1.2.4 - 1.2.3 - 1.2.2 - 1.2.1 - 1.1.4 - 1.1.3 - 1.1.2 - 1.1.1 - 1.0.4 - 1.0.3 - 1.0.2 - 1.0.1 我们也可以安装指定版本的类库 1$ bower install jquery#1.1.2 小结有了bower后,我们不用费心去找各种版本的类库了","tags":[{"name":"bower","slug":"bower","permalink":"http://www.jixingchuan.com/tags/bower/"},{"name":"包管理工具","slug":"包管理工具","permalink":"http://www.jixingchuan.com/tags/包管理工具/"}]},{"title":"Git安装及使用","date":"2016-03-06T00:38:24.000Z","path":"2016/03/06/tools/Git安装及使用/","text":"Git控制流程图 Git安装 以下说明均是基于Window环境(本人电脑环境) msysgit是windows版的git，从https://git-for-windows.github.io下载，然后按默认选项安装即可。 在开始菜单里找到“git”-&gt;“git bash”，蹦出一个类似命令行窗口的东西，说明git安装成功 安装完成后进行以下设置: 12$ git config --global user.name &quot;your name&quot;$ git config --global user.email &quot;email@example.com&quot; 注意:git config命令的–global参数，用了这个参数，表示你这台机器上所有的git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和email地址 创建版本库 版本库又名仓库，英文名repository 创建空目录1234$ mkdir learngit$ cd learngit$ pwd/users/michael/learngit pwd命令用于显示当前目录。在我的mac上，这个仓库位于/users/michael/learngit 为防止出现不可预知的bug,请使用英文目录 通过git init命令把这个目录变成git可以管理的仓库： 12$ git initinitialized empty git repository in /users/michael/learngit/.git/ 瞬间git就把仓库建好了，而且告诉你是一个空的仓库（empty git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把git仓库给破坏了。 如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。 把文件添加到版本库创建一个说明文件readme.txt,输入以下内容 12git is a version control system.git is free software. 第一步，用命令git add告诉git，把文件添加到仓库： 1$ git add readme.txt 第二步，用命令git commit告诉git，把文件提交到仓库： 1234$ git commit -m &quot;wrote a readme file&quot;[master (root-commit) cb926e7] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt 版本控制继续修改readme.txt文件 12git is a distributed version control system.git is free software. 使用git status命令当前状态： 123456789$ git status# on branch master# changes not staged for commit:# (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)# (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)## modified: readme.txt#no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 使用git diff命令查看修改内容: 123456789$ git diff readme.txt diff --git a/readme.txt b/readme.txtindex 46d49bf..9247db6 100644--- a/readme.txt+++ b/readme.txt@@ -1,2 +1,2 @@-git is a version control system.+git is a distributed version control system. git is free software. 提交版本第一步是git add： 1$ git add readme.txt 第二步git commit 1$ git commit -m &quot;add distributed&quot; 小结 要随时掌握工作区的状态，使用git status命令。 如果git status告诉你有文件被修改过，用git diff可以查看修改内容。 版本回退修改readme.txt内容: 12Git is a distributed version control system.Git is free software distributed under the GPL. 提交当前版本: 1234$ git add readme.txt$ git commit -m &quot;append GPL&quot;[master 3628164] append GPL 1 file changed, 1 insertion(+), 1 deletion(-) 使用git add对文件做修改 使用git commit创建版本序列 回顾以下提交过的历史版本:版本1：wrote a readme file 12Git is a version control system.Git is free software. 版本2：add distributed 12Git is a distributed version control system.Git is free software. 版本3：append GPL 12Git is a distributed version control system.Git is free software distributed under the GPL. 使用git log查看commit历史记录 123456789101112131415161718$ git logcommit 3628164fb26d48395383f8f31179f24e0882e1e0Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Tue Aug 20 15:11:49 2013 +0800 append GPLcommit ea34578d5496d7dd233c827ed32a8cd576c5ee85Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Tue Aug 20 14:53:12 2013 +0800 add distributedcommit cb926e7ea50ad11b8f9e909c05226233bf755030Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Mon Aug 19 17:51:55 2013 +0800 wrote a readme file 使用$ git log --pretty=oneline简化显示历史记录 1234$ git log --pretty=oneline3628164fb26d48395383f8f31179f24e0882e1e0 append GPLea34578d5496d7dd233c827ed32a8cd576c5ee85 add distributedcb926e7ea50ad11b8f9e909c05226233bf755030 wrote a readme file 在Git中，用HEAD表示当前版本，也就是最新的提交3628164…882e1e0（每个人的id不同），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 回退到上一个版本“add distributed”，使用git reset命令： 12$ git reset --hard HEAD^HEAD is now at ea34578 add distributed 查看readme.txt当前内容: 123$ cat readme.txtGit is a distributed version control system.Git is free software. 还可以继续回退到上一个版本wrote a readme file，不过且慢，然我们用git log再看看现在版本库的状态： 123456789101112$ git logcommit ea34578d5496d7dd233c827ed32a8cd576c5ee85Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Tue Aug 20 14:53:12 2013 +0800 add distributedcommit cb926e7ea50ad11b8f9e909c05226233bf755030Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Mon Aug 19 17:51:55 2013 +0800 wrote a readme file 只要上面的命令行窗口还没有被关掉,通过commit id可以回到未来版本: 12$ git reset --hard 3628164HEAD is now at 3628164 append GPL 即使关掉命令条,也可以通过git reflog命令查看版本操作记录: 12345$ git reflogea34578 HEAD@&#123;0&#125;: reset: moving to HEAD^3628164 HEAD@&#123;1&#125;: commit: append GPLea34578 HEAD@&#123;2&#125;: commit: add distributedcb926e7 HEAD@&#123;3&#125;: commit (initial): wrote a readme file 小结 HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 工作区和暂存区 git和其他版本控制系统如svn的不同之处就是有暂存区的概念 工作区(working directory)就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区： 版本库(repository)工作区的隐藏目录.git,就是git的版本库 git版本库中存了很多东西,其中最重要的就是stage(或称index)的暂存区,以及git自动创建的第一个分值master,还有指向master的指针head 向git版本库添加,分两步执行: git add,将文件添加到暂存区 git commit,将暂存区的内容提交到当前分支 因为git自动创建master分支,git commit就是想master分支提交更改 管理修改git是如何跟踪修改的，每次修改，如果不add到暂存区，那就不会加入到commit中。 git commit只会提交暂存区上的修改到分支上,如本地修改没有提交到暂存区,那同样不会提交到master分支上 撤消更改 本地做了修改,未提交到暂存区git checkout -- file可以丢弃工作区的修改： 1$ git checkout -- readme.txt 可以让这个文件回到最近一次git commit或git add时的状态 修改已添加到暂存区,未添加到分支用命令git reset head file可以把暂存区的修改撤销掉（unstage），重新放回工作区： 123$ git reset head readme.txtunstaged changes after reset:m readme.txt 小结场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset head file，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 删除文件命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。 命令rm可以删除本地文件 远程仓库添加远程仓库要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git； 关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而svn在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！ 克隆远程仓库要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。 git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。 分支管理创建与合并分支查看分支：git branch 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt; 创建+切换分支：git checkout -b &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt; 解决冲突git log --graph命令可以看到分支合并图 分支管理策略合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。 在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了 Bug分支突然接到任务需要放下工作修改bug分支,可以将工作区内容暂存(需要被git管理)1$ git stash 建立issue分支,修复big 查看暂存文件的列表1$ git stash list 修复完毕后取回暂存的文件12$ git stash apply //取出暂存文件但文件不删除$ git stash pop //取出暂存文件并删除 Feature分支开发一个新feature，最好新建一个分支； 如果要丢弃一个没有被合并过的分支，可以通过git branch -D 强行删除。 多人协作查看远程库信息12$ git remoteorigin 显示更详细的信息123$ git remote -vorigin git@github.com:michaelliao/learngit.git (fetch)origin git@github.com:michaelliao/learngit.git (push) 推送分支推送主分支:1$ git push origin master 推送其他分支:1$ git push origin dev 抓取分支1$ git clone git@github.com:michaelliao/learngit.git 要在dev分支上开发，就必须创建远程origin的dev分支到本地:1$ git checkout -b dev origin/dev 可以将dev上的修改push到远程:12$ git commit -m &quot;add /usr/bin/env&quot;$ git push origin dev 推送冲突远程库上最新提交和你试图推送的提交有冲突，Git提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送：1$ git pull git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接,再pull：1234567$ git branch --set-upstream dev origin/devBranch dev set up to track remote branch dev from origin.$ git pullAuto-merging hello.pyCONFLICT (content): Merge conflict in hello.pyAutomatic merge failed; fix conflicts and then commit the result. git pull成功，但是合并有冲突，需要手动解决:12$ git commit -m &quot;merge &amp; fix hello.py&quot;$ git push origin dev 多人协作的工作模式通常是这样： 首先，可以试图用git push origin branch-name推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并(失败的话需要对本地和远程分支做关联)； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！ 如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name。 这就是多人协作的工作模式，一旦熟悉了，就非常简单。 小结 查看远程库信息，使用git remote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致 建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name； 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 标签管理创建标签1$ git tag v1.0 用命令git tag查看所有标签：12$ git tagv1.0 命令git tag 用于新建一个标签，默认为HEAD，也可以指定一个commit id； git tag -a -m “blablabla…”可以指定标签信息； git tag -s -m “blablabla…”可以用PGP签名标签； 命令git tag可以查看所有标签。 操作标签 命令git push origin 可以推送一个本地标签； 命令git push origin –tags可以推送全部未推送过的本地标签； 命令git tag -d 可以删除一个本地标签； 命令git push origin :refs/tags/可以删除一个远程标签。 Fork参与开源项目在GitHub上，可以任意Fork开源仓库； 自己拥有Fork后的仓库的读写权限； 可以推送pull request给官方仓库来贡献代码 Git自定义忽略特殊文件在.gitignore文件内编写忽略列表 ex1:1234# Windows:Thumbs.dbehthumbs.dbDesktop.ini ex2:1234567# Python:*.py[cod]*.so*.egg*.egg-infodistbuild ex3:12345678910111213141516# Windows:Thumbs.dbehthumbs.dbDesktop.ini# Python:*.py[cod]*.so*.egg*.egg-infodistbuild# My configurations:db.inideploy_key_rsa 小结 忽略某些文件时，需要编写.gitignore； .gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理！ 配置别名使用st就表示status：1$ git config --global alias.st status 还有123$ git config --global alias.co checkout$ git config --global alias.ci commit$ git config --global alias.br branch 搭建Git服务器搭建Git服务器非常简单，通常10分钟即可完成； 要方便管理公钥，用Gitosis； 要像SVN那样变态地控制权限，用Gitolite。","tags":[{"name":"Git","slug":"Git","permalink":"http://www.jixingchuan.com/tags/Git/"}]},{"title":"全局作用域中变量和函数名冲突时的优先级","date":"2016-03-03T11:21:43.000Z","path":"2016/03/03/JavaScript/Javascript-全局作用域中变量和函数名冲突时的优先级/","text":"全局作用域中变量和函数名冲突 全局作用域预解析时,如果变量与函数名相同,以函数为准 变量有赋值时,以变量为准 全局作用域变量名和函数名冲突123456789101112131415161718// 全局作用域变量名和函数名冲突// 1var a1=123;console.log(typeof a1); // numberfunction a1() &#123;&#125;// 2console.log(typeof a2); // functionvar a2=123;function a2() &#123;&#125;// 3var a3=123;function a3() &#123;&#125;console.log(typeof a3); // number// 4var a4;function a4() &#123;&#125;console.log(typeof a4); // functiona4=123; 预解析时,变量名、函数名、和传参冲突12345678910111213141516171819202122232425262728// 预解析时,变量名、函数名、和传参冲突 // 1.预解析,var a 先提升,实参给a赋值,后被222覆盖,输出222 function foo1(a)&#123; var a = 222; console.log(a); //222 &#125; foo1(111); // 2.预解析,var a 先提升,实参先给a赋值,输出111,后被222覆盖 function foo2(a)&#123; console.log(a); //111 var a = 222; &#125; foo2(111); // 3.变量已经被赋值,输出222 function foo3(a)&#123; var a = 222; console.log(a); //222 function a() &#123;&#125; &#125; foo3(111); // 3.变量没有被赋值时,输出a的函数体 function foo4(a)&#123; var a; console.log(a); //a的函数体 a = 222; function a() &#123;console.log(\"qwe\")&#125; &#125; foo4(111);","tags":[{"name":"作用域","slug":"作用域","permalink":"http://www.jixingchuan.com/tags/作用域/"},{"name":"优先级","slug":"优先级","permalink":"http://www.jixingchuan.com/tags/优先级/"}]},{"title":"深复制与浅复制的区别","date":"2016-03-02T02:32:12.000Z","path":"2016/03/02/JavaScript/Javascript-深复制与浅复制的区别/","text":"浅复制浅拷贝是指复制对象的时候，指对第一层键值对进行独立的复制。一个简单的实现如下：123456789101112131415// 浅复制实现function shadowCopy(target, source)&#123; if( !source || typeof source !== 'object')&#123; return; &#125; if( !target || typeof target !== 'object')&#123; return; &#125; // 这边最好区别一下对象和数组的复制 for(var key in source)&#123; if(source.hasOwnProperty(key))&#123; target[key] = source[key]; &#125; &#125;&#125; 我们分别对对象和数组进行测试，发现成功地复制了。123456789101112131415161718//测试例子var arr = [1,2,3];var arr2 = [];shadowCopy(arr2, arr);console.log(arr2);//[1,2,3]var today = &#123; weather: 'Sunny', date: &#123; week: 'Wed' &#125; &#125;var tomorrow = &#123;&#125;;shadowCopy(tomorrow, today);console.log(tomorrow);// Object &#123;weather: \"Sunny\", date: Object&#125; 对于date这个属性，tomorrow变量复制的是它在堆中的地址，这也导致了today和tomorrow的date其实是指向堆中的同一个对象,只是对地址的引用。 12345tomorrow.weather = 'Cloudy';tomorrow.date.week = 'Thurs';console.log(today.weather); // 'Sunny'console.log(today.date.week); //'Thurs' Array方法的slice，concat其实是一种浅复制 深复制深复制的实现,只需要再浅复制的基础上使用递归,复制所有属性和值1234567891011121314151617181920// 深复制实现function deepCopy(target, source)&#123; if( !source || typeof source !== 'object')&#123; return; &#125; if( !target || typeof target !== 'object')&#123; return; &#125; for(var key in source)&#123; if(source.hasOwnProperty(key))&#123; if( source[key] &amp;&amp; typeof source[key] == 'object')&#123; target[key] = &#123;&#125;; deepCopy(target[key], source[key]); &#125; else&#123; target[key] = source[key]; &#125; &#125; &#125; &#125; 深复制可以用JSON格式处理(ES5.API)12345678910111213var data=JSON.parse(JSON.stringify(obj))// 缺点:对于一般的需求是可以满足的，但是它有缺点。// 下例中，可以看到JSON复制会忽略掉值为undefined以及函数表达式。var obj = &#123; a: 1, b: 2, c: undefined, sum: function() &#123; return a + b; &#125;&#125;;var obj2 = JSON.parse(JSON.stringify(obj));console.log(obj2);//Object &#123;a: 1, b: 2&#125;","tags":[{"name":"深复制","slug":"深复制","permalink":"http://www.jixingchuan.com/tags/深复制/"}]},{"title":"rem布局 body元素font-size初始化的必要性","date":"2016-02-13T08:11:18.000Z","path":"2016/02/13/HTML&CSS/font-size初始化的必要性/","text":"在我们进行rem布局时,通常给body设置font-size:14px或font-size:16px来进行初始化,今天来深究一下这是why? 什么是rem布局?我们通过给html元素设置font-size,并给元素设置rem单位,来响应不同手机端的缩放. body元素font-size初始化的必要性font-size是可以被后代元素继承的属性,如果不给body设置font-size值,html下后代元素都会继承html的font-size值.默认设置一般为100px,画风是不是有点奇怪呢. font-size除了影响文字大小,还会影响什么? 今天的重头戏来了,除了影响文字大小,还会影响什么呢? 布局中我们常注意到图片下多出的几像素,这个问题老生常谈了,原因我们已经知道,图片是默认对应baseline的. 前几日,有人找我review代码,有个问题:”input参数设置正确,为什么头顶还有一大片空白呢?” 画风是这样的: input元素未受到padding和margin影响,此时是初始位置 经过排查,是因为body没设置font-size,form元素继承html的字体大小了,那么问题来了,为什么font-size会对input元素产生影响? 大家应该想到之前img元素下方留白的问题了,其原理是一样的,行内元素都是沿font的baseline对齐的 如果font-size设置的过大,baseline就会下移,即使没有文字,行内元素也是会根据baseline走的,自然就出现位移的问题. 如何解决font-size对行内元素的影响? 我们这里讨论不止限于rem布局的方法 我们的目标是达到下图的效果: 行内元素转成块元素 12/*块元素自占一行*/display:block; 浮动 123/*脱离标准流*/float:left;float:right; 定位 123/*脱离标准流*/position:absolute;position:relative; vertical-align 12/*直接改变对齐方式*/vertical-align:top; 以上几种方法都可以解决这个问题","tags":[{"name":"CSS","slug":"CSS","permalink":"http://www.jixingchuan.com/tags/CSS/"},{"name":"Bug","slug":"Bug","permalink":"http://www.jixingchuan.com/tags/Bug/"}]},{"title":"前后端分离的发展过程","date":"2016-01-23T11:59:14.000Z","path":"2016/01/23/works/前后端分离的发展过程/","text":"前后端未分离开发模式的缺点 前端完成页面, 后端翻译成模版, 如果前端界面变动, 需要重新再走一遍流程, 开发效率低 前后端代码强耦合, 维护成本高 前后端分工不明确, 沟通成本高 分离与未分离的比较 交互形式 在前后端分离架构中，后端只需要负责按照约定的数据格式向前端提供可调用的API服务即可.前后端之间通过HTTP请求进行交互，前端获取到数据后，进行页面的装配和渲染. 代码组织方式 半分离 前后端共用一个代码库，但是代码分别存放在两个工程中。后端不关心或很少关心前端元素的输出情况，前端不能独立进行开发和测试，项目中缺乏前后端交互的测试用例 分离 前后端代码库分离，前端代码中有可以进行Mock测试，能支持前端的独立开发和测试.而后端代码中除了功能实现外，还有着详细的测试用例，以保证API的可用性，降低集成风险. 开发模式 前后端未分离的开发流程 提出需求 -&gt; 前端开发 -&gt; 后端翻译成模版 -&gt; 前后端对接 -&gt; 联调遇到问题 -&gt; 前端返工 -&gt; 后端返工 -&gt; 二次集成 -&gt;联调成功 -&gt; 交付 前后端分离后的开发流程 提出需求 -&gt; 约定数据接口 -&gt; 前后端并行开发 -&gt; 前后端联调 -&gt; 前端调整页面 -&gt; 联调成功 -&gt; 交付 在开发模式上, 我们可以看到, 前后端分离不仅仅是工作内容的分离, 更重要的意义是可以并行开发, 简化了工作流程. 前后端分离的几种方案 Nginx + Server 将前端资源部署在Nginx上，后端服务部署在常规的服务器.当浏览器发起访问请求的时候，如果请求的是页面资源，Nginx直接把资源返回到前端；如果请求是调用后端服务，则经过Nginx转发到后端服务器，完成响应后经Nginx返回到浏览器. 缺点: Nginx 只是向浏览器返回页面静态资源，而国内的搜索引擎爬虫只会抓取静态数据，不会解析页面中的js，这使得应用得不到良好的搜索引擎支持. 同时因为 Nginx 不会进行页面的组装渲染，需要服务器把完成渲染工作，这加重了浏览器的渲染负担. Node + Server 这是淘宝所使用的前后端分离模式，在浏览器与后端服务器之间增加一个了Node Server作为中间层，将前端资源部署到 Node Server 中. Node Server 中还包含了一层 Model Proxy，负责与服务端进行通信. 浏览器发出的请求都被Node Server接收，然后通过Model Proxy调用后端服务器提供的服务.Node Server得到后端服务器反馈，接着在Node Server中完成页面的组装渲染，把最终页面返回给浏览器. 缺点: 浏览器所有发出的请求都需要经过Node Server进行中转，然后才能到达后端服务器.在实际的应用中，并不是所有的请求都需要页面渲染，只要在页面上直接调用后端服务器提供的服务即可.所以这个模式必然会对请求性能有所消耗. Nginx + Node + Server 为了能解决方案2中请求性能损失的问题，我们可以考虑在其基础之上增加Nginx.浏览器发起的请求经过Nginx进行分发，URL请求统一分发到Node Server，在Node Server中进行页面组装渲染；API请求则直接发送到后端服务器，完成响应. 作者 : 纪行川 博客 : 行川草庐 声明 : 网站内容可自由转载 , 转载请附上作者信息和详细链接","tags":[{"name":"works","slug":"works","permalink":"http://www.jixingchuan.com/tags/works/"}]}]